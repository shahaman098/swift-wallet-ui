import {
  require_buffer
} from "./chunk-DLMJTLMK.js";
import {
  esm_default,
  external_exports,
  formatUnits,
  getAddress,
  hexZeroPad,
  hexlify,
  parseUnits
} from "./chunk-4HB6NDZX.js";
import "./chunk-WJDDVP4S.js";
import {
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@circle-fin/provider-cctp-v2/index.mjs
var import_buffer = __toESM(require_buffer(), 1);
if (typeof globalThis !== "undefined" && typeof globalThis.Buffer === "undefined") {
  globalThis.Buffer = import_buffer.Buffer;
}
if (typeof window !== "undefined" && typeof window.Buffer === "undefined") {
  window.Buffer = import_buffer.Buffer;
}
var Blockchain;
(function(Blockchain3) {
  Blockchain3["Algorand"] = "Algorand";
  Blockchain3["Algorand_Testnet"] = "Algorand_Testnet";
  Blockchain3["Aptos"] = "Aptos";
  Blockchain3["Aptos_Testnet"] = "Aptos_Testnet";
  Blockchain3["Arc_Testnet"] = "Arc_Testnet";
  Blockchain3["Arbitrum"] = "Arbitrum";
  Blockchain3["Arbitrum_Sepolia"] = "Arbitrum_Sepolia";
  Blockchain3["Avalanche"] = "Avalanche";
  Blockchain3["Avalanche_Fuji"] = "Avalanche_Fuji";
  Blockchain3["Base"] = "Base";
  Blockchain3["Base_Sepolia"] = "Base_Sepolia";
  Blockchain3["Celo"] = "Celo";
  Blockchain3["Celo_Alfajores_Testnet"] = "Celo_Alfajores_Testnet";
  Blockchain3["Codex"] = "Codex";
  Blockchain3["Codex_Testnet"] = "Codex_Testnet";
  Blockchain3["Ethereum"] = "Ethereum";
  Blockchain3["Ethereum_Sepolia"] = "Ethereum_Sepolia";
  Blockchain3["Hedera"] = "Hedera";
  Blockchain3["Hedera_Testnet"] = "Hedera_Testnet";
  Blockchain3["HyperEVM"] = "HyperEVM";
  Blockchain3["HyperEVM_Testnet"] = "HyperEVM_Testnet";
  Blockchain3["Ink"] = "Ink";
  Blockchain3["Ink_Testnet"] = "Ink_Testnet";
  Blockchain3["Linea"] = "Linea";
  Blockchain3["Linea_Sepolia"] = "Linea_Sepolia";
  Blockchain3["NEAR"] = "NEAR";
  Blockchain3["NEAR_Testnet"] = "NEAR_Testnet";
  Blockchain3["Noble"] = "Noble";
  Blockchain3["Noble_Testnet"] = "Noble_Testnet";
  Blockchain3["Optimism"] = "Optimism";
  Blockchain3["Optimism_Sepolia"] = "Optimism_Sepolia";
  Blockchain3["Polkadot_Asset_Hub"] = "Polkadot_Asset_Hub";
  Blockchain3["Polkadot_Westmint"] = "Polkadot_Westmint";
  Blockchain3["Plume"] = "Plume";
  Blockchain3["Plume_Testnet"] = "Plume_Testnet";
  Blockchain3["Polygon"] = "Polygon";
  Blockchain3["Polygon_Amoy_Testnet"] = "Polygon_Amoy_Testnet";
  Blockchain3["Sei"] = "Sei";
  Blockchain3["Sei_Testnet"] = "Sei_Testnet";
  Blockchain3["Solana"] = "Solana";
  Blockchain3["Solana_Devnet"] = "Solana_Devnet";
  Blockchain3["Sonic"] = "Sonic";
  Blockchain3["Sonic_Testnet"] = "Sonic_Testnet";
  Blockchain3["Stellar"] = "Stellar";
  Blockchain3["Stellar_Testnet"] = "Stellar_Testnet";
  Blockchain3["Sui"] = "Sui";
  Blockchain3["Sui_Testnet"] = "Sui_Testnet";
  Blockchain3["Unichain"] = "Unichain";
  Blockchain3["Unichain_Sepolia"] = "Unichain_Sepolia";
  Blockchain3["World_Chain"] = "World_Chain";
  Blockchain3["World_Chain_Sepolia"] = "World_Chain_Sepolia";
  Blockchain3["XDC"] = "XDC";
  Blockchain3["XDC_Apothem"] = "XDC_Apothem";
  Blockchain3["ZKSync_Era"] = "ZKSync_Era";
  Blockchain3["ZKSync_Sepolia"] = "ZKSync_Sepolia";
})(Blockchain || (Blockchain = {}));
function defineChain(chain) {
  return chain;
}
var Algorand = defineChain({
  type: "algorand",
  chain: Blockchain.Algorand,
  name: "Algorand",
  title: "Algorand Mainnet",
  nativeCurrency: {
    name: "Algo",
    symbol: "ALGO",
    decimals: 6
  },
  isTestnet: false,
  explorerUrl: "https://explorer.perawallet.app/tx/{hash}",
  rpcEndpoints: ["https://mainnet-api.algonode.cloud"],
  eurcAddress: null,
  usdcAddress: "31566704",
  cctp: null
});
var AlgorandTestnet = defineChain({
  type: "algorand",
  chain: Blockchain.Algorand_Testnet,
  name: "Algorand Testnet",
  title: "Algorand Test Network",
  nativeCurrency: {
    name: "Algo",
    symbol: "ALGO",
    decimals: 6
  },
  isTestnet: true,
  explorerUrl: "https://testnet.explorer.perawallet.app/tx/{hash}",
  rpcEndpoints: ["https://testnet-api.algonode.cloud"],
  eurcAddress: null,
  usdcAddress: "10458941",
  cctp: null
});
var Aptos = defineChain({
  type: "aptos",
  chain: Blockchain.Aptos,
  name: "Aptos",
  title: "Aptos Mainnet",
  nativeCurrency: {
    name: "Aptos",
    symbol: "APT",
    decimals: 8
  },
  isTestnet: false,
  explorerUrl: "https://explorer.aptoslabs.com/txn/{hash}?network=mainnet",
  rpcEndpoints: ["https://fullnode.mainnet.aptoslabs.com/v1"],
  eurcAddress: null,
  usdcAddress: "0xbae207659db88bea0cbead6da0ed00aac12edcdda169e591cd41c94180b46f3b",
  cctp: {
    domain: 9,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9bce6734f7b63e835108e3bd8c36743d4709fe435f44791918801d0989640a9d",
        messageTransmitter: "0x177e17751820e4b4371873ca8c30279be63bdea63b88ed0f2239c2eea10f1772",
        confirmations: 1
      }
    }
  }
});
var AptosTestnet = defineChain({
  type: "aptos",
  chain: Blockchain.Aptos_Testnet,
  name: "Aptos Testnet",
  title: "Aptos Test Network",
  nativeCurrency: {
    name: "Aptos",
    symbol: "APT",
    decimals: 8
  },
  isTestnet: true,
  explorerUrl: "https://explorer.aptoslabs.com/txn/{hash}?network=testnet",
  rpcEndpoints: ["https://fullnode.testnet.aptoslabs.com/v1"],
  eurcAddress: null,
  usdcAddress: "0x69091fbab5f7d635ee7ac5098cf0c1efbe31d68fec0f2cd565e8d168daf52832",
  cctp: {
    domain: 9,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x5f9b937419dda90aa06c1836b7847f65bbbe3f1217567758dc2488be31a477b9",
        messageTransmitter: "0x081e86cebf457a0c6004f35bd648a2794698f52e0dde09a48619dcd3d4cc23d9",
        confirmations: 1
      }
    }
  }
});
var BRIDGE_CONTRACT_EVM_TESTNET = "0xC5567a5E3370d4DBfB0540025078e283e36A363d";
var BRIDGE_CONTRACT_EVM_MAINNET = "0xB3FA262d0fB521cc93bE83d87b322b8A23DAf3F0";
var ArcTestnet = defineChain({
  type: "evm",
  chain: Blockchain.Arc_Testnet,
  name: "Arc Testnet",
  title: "ArcTestnet",
  nativeCurrency: {
    name: "Arc",
    symbol: "Arc",
    decimals: 18
  },
  chainId: 5042002,
  isTestnet: true,
  explorerUrl: "https://testnet.arcscan.app/tx/{hash}",
  rpcEndpoints: ["https://rpc.testnet.arc.network/"],
  eurcAddress: "0x89B50855Aa3bE2F677cD6303Cec089B5F319D72a",
  usdcAddress: "0x3600000000000000000000000000000000000000",
  cctp: {
    domain: 26,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Arbitrum = defineChain({
  type: "evm",
  chain: Blockchain.Arbitrum,
  name: "Arbitrum",
  title: "Arbitrum Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 42161,
  isTestnet: false,
  explorerUrl: "https://arbiscan.io/tx/{hash}",
  rpcEndpoints: ["https://arb1.arbitrum.io/rpc"],
  eurcAddress: null,
  usdcAddress: "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
  cctp: {
    domain: 3,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x19330d10D9Cc8751218eaf51E8885D058642E08A",
        messageTransmitter: "0xC30362313FBBA5cf9163F0bb16a0e01f01A896ca",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var ArbitrumSepolia = defineChain({
  type: "evm",
  chain: Blockchain.Arbitrum_Sepolia,
  name: "Arbitrum Sepolia",
  title: "Arbitrum Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 421614,
  isTestnet: true,
  explorerUrl: "https://sepolia.arbiscan.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia-rollup.arbitrum.io/rpc"],
  eurcAddress: null,
  usdcAddress: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
  cctp: {
    domain: 3,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0xaCF1ceeF35caAc005e15888dDb8A3515C41B4872",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Avalanche = defineChain({
  type: "evm",
  chain: Blockchain.Avalanche,
  name: "Avalanche",
  title: "Avalanche Mainnet",
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  chainId: 43114,
  isTestnet: false,
  explorerUrl: "https://subnets.avax.network/c-chain/tx/{hash}",
  rpcEndpoints: ["https://api.avax.network/ext/bc/C/rpc"],
  eurcAddress: "0xc891eb4cbdeff6e073e859e987815ed1505c2acd",
  usdcAddress: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
  cctp: {
    domain: 1,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x6b25532e1060ce10cc3b0a99e5683b91bfde6982",
        messageTransmitter: "0x8186359af5f57fbb40c6b14a588d2a59c0c29880",
        confirmations: 1
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var AvalancheFuji = defineChain({
  type: "evm",
  chain: Blockchain.Avalanche_Fuji,
  name: "Avalanche Fuji",
  title: "Avalanche Fuji Testnet",
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  chainId: 43113,
  isTestnet: true,
  explorerUrl: "https://subnets-test.avax.network/c-chain/tx/{hash}",
  eurcAddress: "0x5e44db7996c682e92a960b65ac713a54ad815c6b",
  usdcAddress: "0x5425890298aed601595a70ab815c96711a31bc65",
  cctp: {
    domain: 1,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0xeb08f243e5d3fcff26a9e38ae5520a669f4019d0",
        messageTransmitter: "0xa9fb1b3009dcb79e2fe346c16a604b8fa8ae0a79",
        confirmations: 1
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  rpcEndpoints: ["https://api.avax-test.network/ext/bc/C/rpc"],
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Base = defineChain({
  type: "evm",
  chain: Blockchain.Base,
  name: "Base",
  title: "Base Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 8453,
  isTestnet: false,
  explorerUrl: "https://basescan.org/tx/{hash}",
  rpcEndpoints: ["https://mainnet.base.org", "https://base.publicnode.com"],
  eurcAddress: "0x60a3e35cc302bfa44cb288bc5a4f316fdb1adb42",
  usdcAddress: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
  cctp: {
    domain: 6,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x1682Ae6375C4E4A97e4B583BC394c861A46D8962",
        messageTransmitter: "0xAD09780d193884d503182aD4588450C416D6F9D4",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var BaseSepolia = defineChain({
  type: "evm",
  chain: Blockchain.Base_Sepolia,
  name: "Base Sepolia",
  title: "Base Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 84532,
  isTestnet: true,
  explorerUrl: "https://sepolia.basescan.org/tx/{hash}",
  rpcEndpoints: ["https://sepolia.base.org"],
  eurcAddress: "0x808456652fdb597867f38412077A9182bf77359F",
  usdcAddress: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  cctp: {
    domain: 6,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Celo = defineChain({
  type: "evm",
  chain: Blockchain.Celo,
  name: "Celo",
  title: "Celo Mainnet",
  nativeCurrency: {
    name: "Celo",
    symbol: "CELO",
    decimals: 18
  },
  chainId: 42220,
  isTestnet: false,
  explorerUrl: "https://celoscan.io/tx/{hash}",
  rpcEndpoints: ["https://forno.celo.org"],
  eurcAddress: null,
  usdcAddress: "0xcebA9300f2b948710d2653dD7B07f33A8B32118C",
  cctp: null
});
var CeloAlfajoresTestnet = defineChain({
  type: "evm",
  chain: Blockchain.Celo_Alfajores_Testnet,
  name: "Celo Alfajores",
  title: "Celo Alfajores Testnet",
  nativeCurrency: {
    name: "Celo",
    symbol: "CELO",
    decimals: 18
  },
  chainId: 44787,
  isTestnet: true,
  explorerUrl: "https://alfajores.celoscan.io/tx/{hash}",
  rpcEndpoints: ["https://alfajores-forno.celo-testnet.org"],
  eurcAddress: null,
  usdcAddress: "0x2F25deB3848C207fc8E0c34035B3Ba7fC157602B",
  cctp: null
});
var Codex = defineChain({
  type: "evm",
  chain: Blockchain.Codex,
  name: "Codex Mainnet",
  title: "Codex Mainnet",
  nativeCurrency: {
    name: "ETH",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 81224,
  isTestnet: false,
  explorerUrl: "https://explorer.codex.xyz/tx/{hash}",
  rpcEndpoints: ["https://rpc.codex.xyz"],
  eurcAddress: null,
  usdcAddress: "0xd996633a415985DBd7D6D12f4A4343E31f5037cf",
  cctp: {
    domain: 12,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var CodexTestnet = defineChain({
  type: "evm",
  chain: Blockchain.Codex_Testnet,
  name: "Codex Testnet",
  title: "Codex Testnet",
  nativeCurrency: {
    name: "ETH",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 812242,
  isTestnet: true,
  explorerUrl: "https://explorer.codex-stg.xyz/tx/{hash}",
  rpcEndpoints: ["https://rpc.codex-stg.xyz"],
  eurcAddress: null,
  usdcAddress: "0x6d7f141b6819C2c9CC2f818e6ad549E7Ca090F8f",
  cctp: {
    domain: 12,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Ethereum = defineChain({
  type: "evm",
  chain: Blockchain.Ethereum,
  name: "Ethereum",
  title: "Ethereum Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 1,
  isTestnet: false,
  explorerUrl: "https://etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://eth.merkle.io", "https://ethereum.publicnode.com"],
  eurcAddress: "0x1aBaEA1f7C830bD89Acc67eC4af516284b1bC33c",
  usdcAddress: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  cctp: {
    domain: 0,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0xbd3fa81b58ba92a82136038b25adec7066af3155",
        messageTransmitter: "0x0a992d191deec32afe36203ad87d7d289a738f81",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 2
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var EthereumSepolia = defineChain({
  type: "evm",
  chain: Blockchain.Ethereum_Sepolia,
  name: "Ethereum Sepolia",
  title: "Ethereum Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 11155111,
  isTestnet: true,
  explorerUrl: "https://sepolia.etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia.drpc.org"],
  eurcAddress: "0x08210F9170F89Ab7658F0B5E3fF39b0E03C594D4",
  usdcAddress: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
  cctp: {
    domain: 0,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 2
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Hedera = defineChain({
  type: "hedera",
  chain: Blockchain.Hedera,
  name: "Hedera",
  title: "Hedera Mainnet",
  nativeCurrency: {
    name: "HBAR",
    symbol: "HBAR",
    decimals: 18
  },
  isTestnet: false,
  explorerUrl: "https://hashscan.io/mainnet/transaction/{hash}",
  // Note: Hedera uses `transaction_id`, not hash. Format is typically `0.0.X-YYYY...`.
  rpcEndpoints: ["https://mainnet.hashio.io/api"],
  eurcAddress: null,
  usdcAddress: "0.0.456858",
  cctp: null
});
var HederaTestnet = defineChain({
  type: "hedera",
  chain: Blockchain.Hedera_Testnet,
  name: "Hedera Testnet",
  title: "Hedera Test Network",
  nativeCurrency: {
    name: "HBAR",
    symbol: "HBAR",
    decimals: 18
  },
  isTestnet: true,
  explorerUrl: "https://hashscan.io/testnet/transaction/{hash}",
  // Note: Hedera uses `transaction_id`, not hash. Format is typically `0.0.X-YYYY...`.
  rpcEndpoints: ["https://testnet.hashio.io/api"],
  eurcAddress: null,
  usdcAddress: "0.0.429274",
  cctp: null
});
var HyperEVM = defineChain({
  type: "evm",
  chain: Blockchain.HyperEVM,
  name: "HyperEVM",
  title: "HyperEVM Mainnet",
  nativeCurrency: {
    name: "Hype",
    symbol: "HYPE",
    decimals: 18
  },
  chainId: 999,
  isTestnet: false,
  explorerUrl: "https://hyperevmscan.io/tx/{hash}",
  rpcEndpoints: ["https://rpc.hyperliquid.xyz/evm"],
  eurcAddress: null,
  usdcAddress: "0xb88339CB7199b77E23DB6E890353E22632Ba630f",
  cctp: {
    domain: 19,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var HyperEVMTestnet = defineChain({
  type: "evm",
  chain: Blockchain.HyperEVM_Testnet,
  name: "HyperEVM Testnet",
  title: "HyperEVM Test Network",
  nativeCurrency: {
    name: "Hype",
    symbol: "HYPE",
    decimals: 18
  },
  chainId: 998,
  isTestnet: true,
  explorerUrl: "https://testnet.hyperliquid.xyz/explorer/tx/{hash}",
  rpcEndpoints: ["https://rpc.hyperliquid-testnet.xyz/evm"],
  eurcAddress: null,
  usdcAddress: "0x2B3370eE501B4a559b57D449569354196457D8Ab",
  cctp: {
    domain: 19,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Ink = defineChain({
  type: "evm",
  chain: Blockchain.Ink,
  name: "Ink",
  title: "Ink Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 57073,
  isTestnet: false,
  explorerUrl: "https://explorer.inkonchain.com/tx/{hash}",
  rpcEndpoints: [
    "https://rpc-gel.inkonchain.com",
    "https://rpc-qnd.inkonchain.com"
  ],
  eurcAddress: null,
  usdcAddress: "0x2D270e6886d130D724215A266106e6832161EAEd",
  cctp: {
    domain: 21,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var InkTestnet = defineChain({
  type: "evm",
  chain: Blockchain.Ink_Testnet,
  name: "Ink Sepolia",
  title: "Ink Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 763373,
  isTestnet: true,
  explorerUrl: "https://explorer-sepolia.inkonchain.com/tx/{hash}",
  rpcEndpoints: [
    "https://rpc-gel-sepolia.inkonchain.com",
    "https://rpc-qnd-sepolia.inkonchain.com"
  ],
  eurcAddress: null,
  usdcAddress: "0xFabab97dCE620294D2B0b0e46C68964e326300Ac",
  cctp: {
    domain: 21,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Linea = defineChain({
  type: "evm",
  chain: Blockchain.Linea,
  name: "Linea",
  title: "Linea Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 59144,
  isTestnet: false,
  explorerUrl: "https://lineascan.build/tx/{hash}",
  rpcEndpoints: ["https://rpc.linea.build"],
  eurcAddress: null,
  usdcAddress: "0x176211869ca2b568f2a7d4ee941e073a821ee1ff",
  cctp: {
    domain: 11,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var LineaSepolia = defineChain({
  type: "evm",
  chain: Blockchain.Linea_Sepolia,
  name: "Linea Sepolia",
  title: "Linea Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 59141,
  isTestnet: true,
  explorerUrl: "https://sepolia.lineascan.build/tx/{hash}",
  rpcEndpoints: ["https://rpc.sepolia.linea.build"],
  eurcAddress: null,
  usdcAddress: "0xfece4462d57bd51a6a552365a011b95f0e16d9b7",
  cctp: {
    domain: 11,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var NEAR = defineChain({
  type: "near",
  chain: Blockchain.NEAR,
  name: "NEAR Protocol",
  title: "NEAR Mainnet",
  nativeCurrency: {
    name: "NEAR",
    symbol: "NEAR",
    decimals: 24
  },
  isTestnet: false,
  explorerUrl: "https://nearblocks.io/txns/{hash}",
  rpcEndpoints: ["https://eth-rpc.mainnet.near.org"],
  eurcAddress: null,
  usdcAddress: "17208628f84f5d6ad33f0da3bbbeb27ffcb398eac501a31bd6ad2011e36133a1",
  cctp: null
});
var NEARTestnet = defineChain({
  type: "near",
  chain: Blockchain.NEAR_Testnet,
  name: "NEAR Protocol Testnet",
  title: "NEAR Test Network",
  nativeCurrency: {
    name: "NEAR",
    symbol: "NEAR",
    decimals: 24
  },
  isTestnet: true,
  explorerUrl: "https://testnet.nearblocks.io/txns/{hash}",
  rpcEndpoints: ["https://eth-rpc.testnet.near.org"],
  eurcAddress: null,
  usdcAddress: "3e2210e1184b45b64c8a434c0a7e7b23cc04ea7eb7a6c3c32520d03d4afcb8af",
  cctp: null
});
var Noble = defineChain({
  type: "noble",
  chain: Blockchain.Noble,
  name: "Noble",
  title: "Noble Mainnet",
  nativeCurrency: {
    name: "Noble USDC",
    symbol: "USDC",
    decimals: 6
  },
  isTestnet: false,
  explorerUrl: "https://www.mintscan.io/noble/tx/{hash}",
  rpcEndpoints: ["https://noble-rpc.polkachu.com"],
  eurcAddress: null,
  usdcAddress: "uusdc",
  cctp: {
    domain: 4,
    contracts: {
      v1: {
        type: "merged",
        contract: "noble12l2w4ugfz4m6dd73yysz477jszqnfughxvkss5",
        confirmations: 1
      }
    }
  }
});
var NobleTestnet = defineChain({
  type: "noble",
  chain: Blockchain.Noble_Testnet,
  name: "Noble Testnet",
  title: "Noble Test Network",
  nativeCurrency: {
    name: "Noble USDC",
    symbol: "USDC",
    decimals: 6
  },
  isTestnet: true,
  explorerUrl: "https://www.mintscan.io/noble-testnet/tx/{hash}",
  rpcEndpoints: ["https://noble-testnet-rpc.polkachu.com"],
  eurcAddress: null,
  usdcAddress: "uusdc",
  cctp: {
    domain: 4,
    contracts: {
      v1: {
        type: "merged",
        contract: "noble12l2w4ugfz4m6dd73yysz477jszqnfughxvkss5",
        confirmations: 1
      }
    }
  }
});
var Optimism = defineChain({
  type: "evm",
  chain: Blockchain.Optimism,
  name: "Optimism",
  title: "Optimism Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 10,
  isTestnet: false,
  explorerUrl: "https://optimistic.etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://mainnet.optimism.io"],
  eurcAddress: null,
  usdcAddress: "0x0b2c639c533813f4aa9d7837caf62653d097ff85",
  cctp: {
    domain: 2,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x2B4069517957735bE00ceE0fadAE88a26365528f",
        messageTransmitter: "0x0a992d191deec32afe36203ad87d7d289a738f81",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var OptimismSepolia = defineChain({
  type: "evm",
  chain: Blockchain.Optimism_Sepolia,
  name: "Optimism Sepolia",
  title: "Optimism Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 11155420,
  isTestnet: true,
  explorerUrl: "https://sepolia-optimistic.etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia.optimism.io"],
  eurcAddress: null,
  usdcAddress: "0x5fd84259d66Cd46123540766Be93DFE6D43130D7",
  cctp: {
    domain: 2,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Plume = defineChain({
  type: "evm",
  chain: Blockchain.Plume,
  name: "Plume",
  title: "Plume Mainnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  chainId: 98866,
  isTestnet: false,
  explorerUrl: "https://explorer.plume.org/tx/{hash}",
  rpcEndpoints: ["https://rpc.plume.org"],
  eurcAddress: null,
  usdcAddress: "0x222365EF19F7947e5484218551B56bb3965Aa7aF",
  cctp: {
    domain: 22,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var PlumeTestnet = defineChain({
  type: "evm",
  chain: Blockchain.Plume_Testnet,
  name: "Plume Testnet",
  title: "Plume Test Network",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  chainId: 98867,
  isTestnet: true,
  explorerUrl: "https://testnet-explorer.plume.org/tx/{hash}",
  rpcEndpoints: ["https://testnet-rpc.plume.org"],
  eurcAddress: null,
  usdcAddress: "0xcB5f30e335672893c7eb944B374c196392C19D18",
  cctp: {
    domain: 22,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var PolkadotAssetHub = defineChain({
  type: "polkadot",
  chain: Blockchain.Polkadot_Asset_Hub,
  name: "Polkadot Asset Hub",
  title: "Polkadot Asset Hub",
  nativeCurrency: {
    name: "Polkadot",
    symbol: "DOT",
    decimals: 10
  },
  isTestnet: false,
  explorerUrl: "https://polkadot.subscan.io/extrinsic/{hash}",
  rpcEndpoints: ["https://asset-hub-polkadot-rpc.n.dwellir.com"],
  eurcAddress: null,
  usdcAddress: "1337",
  cctp: null
});
var PolkadotWestmint = defineChain({
  type: "polkadot",
  chain: Blockchain.Polkadot_Westmint,
  name: "Polkadot Westmint",
  title: "Polkadot Westmint",
  nativeCurrency: {
    name: "Polkadot",
    symbol: "DOT",
    decimals: 10
  },
  isTestnet: false,
  explorerUrl: "https://assethub-polkadot.subscan.io/extrinsic/{hash}",
  rpcEndpoints: ["https://westmint-rpc.polkadot.io"],
  eurcAddress: null,
  usdcAddress: "Asset ID 31337",
  cctp: null
});
var Polygon = defineChain({
  type: "evm",
  chain: Blockchain.Polygon,
  name: "Polygon",
  title: "Polygon Mainnet",
  nativeCurrency: {
    name: "POL",
    symbol: "POL",
    decimals: 18
  },
  chainId: 137,
  isTestnet: false,
  explorerUrl: "https://polygonscan.com/tx/{hash}",
  rpcEndpoints: ["https://polygon-rpc.com", "https://polygon.publicnode.com"],
  eurcAddress: null,
  usdcAddress: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
  cctp: {
    domain: 7,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9daF8c91AEFAE50b9c0E69629D3F6Ca40cA3B3FE",
        messageTransmitter: "0xF3be9355363857F3e001be68856A2f96b4C39Ba9",
        confirmations: 200
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 33,
        fastConfirmations: 13
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var PolygonAmoy = defineChain({
  type: "evm",
  chain: Blockchain.Polygon_Amoy_Testnet,
  name: "Polygon Amoy",
  title: "Polygon Amoy Testnet",
  nativeCurrency: {
    name: "POL",
    symbol: "POL",
    decimals: 18
  },
  chainId: 80002,
  isTestnet: true,
  explorerUrl: "https://amoy.polygonscan.com/tx/{hash}",
  rpcEndpoints: ["https://rpc-amoy.polygon.technology"],
  eurcAddress: null,
  usdcAddress: "0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",
  cctp: {
    domain: 7,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 200
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 33,
        fastConfirmations: 13
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Sei = defineChain({
  type: "evm",
  chain: Blockchain.Sei,
  name: "Sei",
  title: "Sei Mainnet",
  nativeCurrency: {
    name: "Sei",
    symbol: "SEI",
    decimals: 18
  },
  chainId: 1329,
  isTestnet: false,
  explorerUrl: "https://seitrace.com/tx/{hash}?chain=pacific-1",
  rpcEndpoints: ["https://evm-rpc.sei-apis.com"],
  eurcAddress: null,
  usdcAddress: "0xe15fC38F6D8c56aF07bbCBe3BAf5708A2Bf42392",
  cctp: {
    domain: 16,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var SeiTestnet = defineChain({
  type: "evm",
  chain: Blockchain.Sei_Testnet,
  name: "Sei Testnet",
  title: "Sei Test Network",
  nativeCurrency: {
    name: "Sei",
    symbol: "SEI",
    decimals: 18
  },
  chainId: 1328,
  isTestnet: true,
  explorerUrl: "https://seitrace.com/tx/{hash}?chain=atlantic-2",
  rpcEndpoints: ["https://evm-rpc-testnet.sei-apis.com"],
  eurcAddress: null,
  usdcAddress: "0x4fCF1784B31630811181f670Aea7A7bEF803eaED",
  cctp: {
    domain: 16,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Sonic = defineChain({
  type: "evm",
  chain: Blockchain.Sonic,
  name: "Sonic",
  title: "Sonic Mainnet",
  nativeCurrency: {
    name: "Sonic",
    symbol: "S",
    decimals: 18
  },
  chainId: 146,
  isTestnet: false,
  explorerUrl: "https://sonicscan.org/tx/{hash}",
  rpcEndpoints: ["https://rpc.soniclabs.com"],
  eurcAddress: null,
  usdcAddress: "0x29219dd400f2Bf60E5a23d13Be72B486D4038894",
  cctp: {
    domain: 13,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var SonicTestnet = defineChain({
  type: "evm",
  chain: Blockchain.Sonic_Testnet,
  name: "Sonic Testnet",
  title: "Sonic Testnet",
  nativeCurrency: {
    name: "Sonic",
    symbol: "S",
    decimals: 18
  },
  chainId: 14601,
  isTestnet: true,
  explorerUrl: "https://testnet.sonicscan.org/tx/{hash}",
  rpcEndpoints: ["https://rpc.testnet.soniclabs.com"],
  eurcAddress: null,
  usdcAddress: "0x0BA304580ee7c9a980CF72e55f5Ed2E9fd30Bc51",
  cctp: {
    domain: 13,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var Solana = defineChain({
  type: "solana",
  chain: Blockchain.Solana,
  name: "Solana",
  title: "Solana Mainnet",
  nativeCurrency: {
    name: "Solana",
    symbol: "SOL",
    decimals: 9
  },
  isTestnet: false,
  explorerUrl: "https://solscan.io/tx/{hash}",
  rpcEndpoints: ["https://api.mainnet-beta.solana.com"],
  eurcAddress: "HzwqbKZw8HxMN6bF2yFZNrht3c2iXXzpKcFu7uBEDKtr",
  usdcAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  cctp: {
    domain: 5,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3",
        messageTransmitter: "CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd",
        confirmations: 32
      },
      v2: {
        type: "split",
        tokenMessenger: "CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe",
        messageTransmitter: "CCTPV2Sm4AdWt5296sk4P66VBZ7bEhcARwFaaS9YPbeC",
        confirmations: 32,
        fastConfirmations: 3
      }
    }
  },
  kitContracts: {
    bridge: "DFaauJEjmiHkPs1JG89A4p95hDWi9m9SAEERY1LQJiC3"
  }
});
var SolanaDevnet = defineChain({
  type: "solana",
  chain: Blockchain.Solana_Devnet,
  name: "Solana Devnet",
  title: "Solana Development Network",
  nativeCurrency: {
    name: "Solana",
    symbol: "SOL",
    decimals: 9
  },
  isTestnet: true,
  explorerUrl: "https://solscan.io/tx/{hash}?cluster=devnet",
  eurcAddress: "HzwqbKZw8HxMN6bF2yFZNrht3c2iXXzpKcFu7uBEDKtr",
  usdcAddress: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
  cctp: {
    domain: 5,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3",
        messageTransmitter: "CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd",
        confirmations: 32
      },
      v2: {
        type: "split",
        tokenMessenger: "CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe",
        messageTransmitter: "CCTPV2Sm4AdWt5296sk4P66VBZ7bEhcARwFaaS9YPbeC",
        confirmations: 32,
        fastConfirmations: 3
      }
    }
  },
  kitContracts: {
    bridge: "DFaauJEjmiHkPs1JG89A4p95hDWi9m9SAEERY1LQJiC3"
  },
  rpcEndpoints: ["https://api.devnet.solana.com"]
});
var Stellar = defineChain({
  type: "stellar",
  chain: Blockchain.Stellar,
  name: "Stellar",
  title: "Stellar Mainnet",
  nativeCurrency: {
    name: "Stellar Lumens",
    symbol: "XLM",
    decimals: 7
  },
  isTestnet: false,
  explorerUrl: "https://stellar.expert/explorer/public/tx/{hash}",
  rpcEndpoints: ["https://horizon.stellar.org"],
  eurcAddress: "EURC-GDHU6WRG4IEQXM5NZ4BMPKOXHW76MZM4Y2IEMFDVXBSDP6SJY4ITNPP2",
  usdcAddress: "USDC-GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN",
  cctp: null
});
var StellarTestnet = defineChain({
  type: "stellar",
  chain: Blockchain.Stellar_Testnet,
  name: "Stellar Testnet",
  title: "Stellar Test Network",
  nativeCurrency: {
    name: "Stellar Lumens",
    symbol: "XLM",
    decimals: 7
  },
  isTestnet: true,
  explorerUrl: "https://stellar.expert/explorer/testnet/tx/{hash}",
  rpcEndpoints: ["https://horizon-testnet.stellar.org"],
  eurcAddress: "EURC-GB3Q6QDZYTHWT7E5PVS3W7FUT5GVAFC5KSZFFLPU25GO7VTC3NM2ZTVO",
  usdcAddress: "USDC-GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
  cctp: null
});
var Sui = defineChain({
  type: "sui",
  chain: Blockchain.Sui,
  name: "Sui",
  title: "Sui Mainnet",
  nativeCurrency: {
    name: "Sui",
    symbol: "SUI",
    decimals: 9
  },
  isTestnet: false,
  explorerUrl: "https://suiscan.xyz/mainnet/tx/{hash}",
  rpcEndpoints: ["https://fullnode.mainnet.sui.io"],
  eurcAddress: null,
  usdcAddress: "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
  cctp: {
    domain: 8,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x2aa6c5d56376c371f88a6cc42e852824994993cb9bab8d3e6450cbe3cb32b94e",
        messageTransmitter: "0x08d87d37ba49e785dde270a83f8e979605b03dc552b5548f26fdf2f49bf7ed1b",
        confirmations: 1
      }
    }
  }
});
var SuiTestnet = defineChain({
  type: "sui",
  chain: Blockchain.Sui_Testnet,
  name: "Sui Testnet",
  title: "Sui Test Network",
  nativeCurrency: {
    name: "Sui",
    symbol: "SUI",
    decimals: 9
  },
  isTestnet: true,
  explorerUrl: "https://suiscan.xyz/testnet/tx/{hash}",
  rpcEndpoints: ["https://fullnode.testnet.sui.io"],
  eurcAddress: null,
  usdcAddress: "0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC",
  cctp: {
    domain: 8,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x31cc14d80c175ae39777c0238f20594c6d4869cfab199f40b69f3319956b8beb",
        messageTransmitter: "0x4931e06dce648b3931f890035bd196920770e913e43e45990b383f6486fdd0a5",
        confirmations: 1
      }
    }
  }
});
var Unichain = defineChain({
  type: "evm",
  chain: Blockchain.Unichain,
  name: "Unichain",
  title: "Unichain Mainnet",
  nativeCurrency: {
    name: "Uni",
    symbol: "UNI",
    decimals: 18
  },
  chainId: 130,
  isTestnet: false,
  explorerUrl: "https://unichain.blockscout.com/tx/{hash}",
  rpcEndpoints: ["https://rpc.unichain.org", "https://mainnet.unichain.org"],
  eurcAddress: null,
  usdcAddress: "0x078D782b760474a361dDA0AF3839290b0EF57AD6",
  cctp: {
    domain: 10,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x4e744b28E787c3aD0e810eD65A24461D4ac5a762",
        messageTransmitter: "0x353bE9E2E38AB1D19104534e4edC21c643Df86f4",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var UnichainSepolia = defineChain({
  type: "evm",
  chain: Blockchain.Unichain_Sepolia,
  name: "Unichain Sepolia",
  title: "Unichain Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Uni",
    symbol: "UNI",
    decimals: 18
  },
  chainId: 1301,
  isTestnet: true,
  explorerUrl: "https://unichain-sepolia.blockscout.com/tx/{hash}",
  rpcEndpoints: ["https://sepolia.unichain.org"],
  eurcAddress: null,
  usdcAddress: "0x31d0220469e10c4E71834a79b1f276d740d3768F",
  cctp: {
    domain: 10,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x8ed94B8dAd2Dc5453862ea5e316A8e71AAed9782",
        messageTransmitter: "0xbc498c326533d675cf571B90A2Ced265ACb7d086",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var WorldChain = defineChain({
  type: "evm",
  chain: Blockchain.World_Chain,
  name: "World Chain",
  title: "World Chain",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 480,
  isTestnet: false,
  explorerUrl: "https://worldscan.org/tx/{hash}",
  rpcEndpoints: ["https://worldchain-mainnet.g.alchemy.com/public"],
  eurcAddress: null,
  usdcAddress: "0x79A02482A880bCe3F13E09da970dC34dB4cD24D1",
  cctp: {
    domain: 14,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cF5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var WorldChainSepolia = defineChain({
  type: "evm",
  chain: Blockchain.World_Chain_Sepolia,
  name: "World Chain Sepolia",
  title: "World Chain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 4801,
  isTestnet: true,
  explorerUrl: "https://sepolia.worldscan.org/tx/{hash}",
  rpcEndpoints: [
    "https://worldchain-sepolia.drpc.org",
    "https://worldchain-sepolia.g.alchemy.com/public"
  ],
  eurcAddress: null,
  usdcAddress: "0x66145f38cBAC35Ca6F1Dfb4914dF98F1614aeA88",
  cctp: {
    domain: 14,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var XDC = defineChain({
  type: "evm",
  chain: Blockchain.XDC,
  name: "XDC",
  title: "XDC Mainnet",
  nativeCurrency: {
    name: "XDC",
    symbol: "XDC",
    decimals: 18
  },
  chainId: 50,
  isTestnet: false,
  explorerUrl: "https://xdcscan.io/tx/{hash}",
  rpcEndpoints: ["https://erpc.xinfin.network"],
  eurcAddress: null,
  usdcAddress: "0xfA2958CB79b0491CC627c1557F441eF849Ca8eb1",
  cctp: {
    domain: 18,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 3,
        fastConfirmations: 3
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET
  }
});
var XDCApothem = defineChain({
  type: "evm",
  chain: Blockchain.XDC_Apothem,
  name: "Apothem Network",
  title: "Apothem Network",
  nativeCurrency: {
    name: "TXDC",
    symbol: "TXDC",
    decimals: 18
  },
  chainId: 51,
  isTestnet: true,
  explorerUrl: "https://testnet.xdcscan.com/tx/{hash}",
  rpcEndpoints: ["https://erpc.apothem.network"],
  eurcAddress: null,
  usdcAddress: "0xb5AB69F7bBada22B28e79C8FFAECe55eF1c771D4",
  cctp: {
    domain: 18,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 3,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET
  }
});
var ZKSyncEra = defineChain({
  type: "evm",
  chain: Blockchain.ZKSync_Era,
  name: "ZKSync Era",
  title: "ZKSync Era Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 324,
  isTestnet: false,
  explorerUrl: "https://explorer.zksync.io/tx/{hash}",
  rpcEndpoints: ["https://mainnet.era.zksync.io"],
  eurcAddress: null,
  usdcAddress: "0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4",
  cctp: null
});
var ZKSyncEraSepolia = defineChain({
  type: "evm",
  chain: Blockchain.ZKSync_Sepolia,
  name: "ZKSync Era Sepolia",
  title: "ZKSync Era Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 300,
  isTestnet: true,
  explorerUrl: "https://sepolia.explorer.zksync.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia.era.zksync.dev"],
  eurcAddress: null,
  usdcAddress: "0xAe045DE5638162fa134807Cb558E15A3F5A7F853",
  cctp: null
});
var Chains = Object.freeze({
  __proto__: null,
  Algorand,
  AlgorandTestnet,
  Aptos,
  AptosTestnet,
  Arbitrum,
  ArbitrumSepolia,
  ArcTestnet,
  Avalanche,
  AvalancheFuji,
  Base,
  BaseSepolia,
  Celo,
  CeloAlfajoresTestnet,
  Codex,
  CodexTestnet,
  Ethereum,
  EthereumSepolia,
  Hedera,
  HederaTestnet,
  HyperEVM,
  HyperEVMTestnet,
  Ink,
  InkTestnet,
  Linea,
  LineaSepolia,
  NEAR,
  NEARTestnet,
  Noble,
  NobleTestnet,
  Optimism,
  OptimismSepolia,
  Plume,
  PlumeTestnet,
  PolkadotAssetHub,
  PolkadotWestmint,
  Polygon,
  PolygonAmoy,
  Sei,
  SeiTestnet,
  Solana,
  SolanaDevnet,
  Sonic,
  SonicTestnet,
  Stellar,
  StellarTestnet,
  Sui,
  SuiTestnet,
  Unichain,
  UnichainSepolia,
  WorldChain,
  WorldChainSepolia,
  XDC,
  XDCApothem,
  ZKSyncEra,
  ZKSyncEraSepolia
});
function isCCTPV2Supported(chain) {
  var _a;
  return ((_a = chain.cctp) == null ? void 0 : _a.contracts.v2) !== void 0;
}
function hasCustomContractSupport(chain, contractType) {
  var _a;
  const contractAddress = (_a = chain.kitContracts) == null ? void 0 : _a[contractType];
  return typeof contractAddress === "string" && contractAddress.trim().length > 0;
}
var baseChainDefinitionSchema = external_exports.object({
  chain: external_exports.nativeEnum(Blockchain, {
    required_error: "Chain enum is required. Please provide a valid Blockchain enum value.",
    invalid_type_error: "Chain must be a valid Blockchain enum value."
  }),
  name: external_exports.string({
    required_error: "Chain name is required. Please provide a valid chain name.",
    invalid_type_error: "Chain name must be a string."
  }),
  title: external_exports.string().optional(),
  nativeCurrency: external_exports.object({
    name: external_exports.string(),
    symbol: external_exports.string(),
    decimals: external_exports.number()
  }),
  isTestnet: external_exports.boolean({
    required_error: "isTestnet is required. Please specify whether this is a testnet.",
    invalid_type_error: "isTestnet must be a boolean."
  }),
  explorerUrl: external_exports.string({
    required_error: "Explorer URL is required. Please provide a valid explorer URL.",
    invalid_type_error: "Explorer URL must be a string."
  }),
  rpcEndpoints: external_exports.array(external_exports.string()),
  eurcAddress: external_exports.string().nullable(),
  usdcAddress: external_exports.string().nullable(),
  cctp: external_exports.any().nullable(),
  // We'll accept any CCTP config structure
  kitContracts: external_exports.object({
    bridge: external_exports.string().optional()
  }).optional()
});
var evmChainDefinitionSchema = baseChainDefinitionSchema.extend({
  type: external_exports.literal("evm"),
  chainId: external_exports.number({
    required_error: "EVM chains must have a chainId. Please provide a valid EVM chain ID.",
    invalid_type_error: "EVM chain ID must be a number."
  })
}).strict();
var nonEvmChainDefinitionSchema = baseChainDefinitionSchema.extend({
  type: external_exports.enum([
    "algorand",
    "avalanche",
    "solana",
    "aptos",
    "near",
    "stellar",
    "sui",
    "hedera",
    "noble",
    "polkadot"
  ])
}).strict();
var chainDefinitionSchema$1 = external_exports.discriminatedUnion("type", [
  evmChainDefinitionSchema,
  nonEvmChainDefinitionSchema
]);
external_exports.union([
  external_exports.string().refine((val) => val in Blockchain, "Must be a valid Blockchain enum value as string"),
  external_exports.nativeEnum(Blockchain),
  chainDefinitionSchema$1
]);
var getChainByEnum = (blockchain) => {
  const chain = Object.values(Chains).find((chain2) => {
    return chain2.chain === blockchain;
  });
  if (!chain) {
    throw new Error(`No chain definition found for blockchain: ${blockchain}`);
  }
  return chain;
};
function resolveChainIdentifier(chainIdentifier) {
  if (typeof chainIdentifier === "object") {
    return chainIdentifier;
  }
  if (typeof chainIdentifier === "string") {
    return getChainByEnum(chainIdentifier);
  }
  throw new Error(`Invalid chain identifier type: ${typeof chainIdentifier}. Expected ChainDefinition object, Blockchain enum, or string literal.`);
}
var resolveCCTPV2ContractAddress = (chain, contractType) => {
  var _a;
  if (hasCustomContractSupport(chain, "bridge") && ((_a = chain.kitContracts) == null ? void 0 : _a.bridge) !== void 0) {
    return chain.kitContracts.bridge;
  }
  const cctpConfig = chain.cctp;
  const contracts = cctpConfig.contracts.v2;
  switch (contracts.type) {
    case "split":
      return contracts.tokenMessenger;
    case "merged":
      return contracts.contract;
    default: {
      const unknownContract = contracts;
      throw new Error(`Unsupported CCTP v2 contract type on chain ${chain.name}. Expected "split" or "merged", but received '${unknownContract.type ?? "unknown"}'.`);
    }
  }
};
var BridgingProvider = class {
  constructor() {
    /**
     * The action dispatcher for this provider.
     *
     * This property holds a reference to an action dispatcher that can be used to
     * dispatch events or actions during the transfer process. It is optional and
     * can be null if no dispatcher is registered.
     */
    __publicField(this, "actionDispatcher", null);
    /**
     * Type-level map of action names to their payload types.
     * This property exists only at the type level and is used for TypeScript inference.
     */
    __publicField(this, "actions");
  }
  /**
   * Get all destination chains that are supported for transfers from the given source chain.
   *
   * This method filters the provider's supported chains to return only those that are
   * compatible with the source chain. Compatibility is determined by matching testnet
   * status (mainnet chains can only transfer to mainnet chains, testnets to testnets)
   * and excluding the source chain itself.
   *
   * @param source - The source chain definition to find compatible destinations for
   * @returns Array of chain definitions that can serve as destinations for the given source
   *
   * @example
   * ```typescript
   * const provider = new BridgingProvider()
   * const destinations = provider.getSupportedDestinationsFor(Ethereum)
   * console.log('Available destinations from Ethereum:', destinations.map(d => d.name))
   * ```
   */
  getSupportedDestinationsFor(source) {
    return this.supportedChains.filter((chain) => chain.isTestnet === source.isTestnet && chain.chain !== source.chain);
  }
  /**
   * Register an event dispatcher for handling provider-specific actions and events.
   *
   *
   * @param dispatcher - The event dispatcher implementing the Actionable interface
   *
   * @example
   * ```typescript
   * const provider = new BridgingProvider()
   *
   * const actionDispatcher = new Actionable()
   *
   * provider.registerDispatcher(actionDispatcher)
   *
   * // Now provider actions will be dispatched to the action dispatcher
   * await provider.bridge(transferParams)
   * ```
   */
  registerDispatcher(dispatcher) {
    this.actionDispatcher = dispatcher;
  }
  supportsRetry() {
    return false;
  }
  async retry() {
    return Promise.reject(new Error("Retry not supported by this provider"));
  }
  analyzeStepsForRetry() {
    throw new Error("Step analysis not supported by this provider");
  }
};
var getRuntime = () => {
  if (typeof process !== "undefined" && typeof process.versions === "object" && typeof process.versions.node === "string") {
    const majorVersion = process.versions.node.split(".")[0] ?? "unknown";
    return `node/${majorVersion}`;
  }
  if (typeof window !== "undefined" && typeof navigator !== "undefined") {
    const userAgent = navigator.userAgent;
    const browserMatchers = {
      Edge: (ua) => ua.includes("Edg"),
      Chrome: (ua) => ua.includes("Chrome") && !ua.includes("Edg"),
      Firefox: (ua) => ua.includes("Firefox"),
      Safari: (ua) => ua.includes("Safari") && !ua.includes("Chrome"),
      Opera: (ua) => ua.includes("Opera") || ua.includes("OPR")
    };
    for (const [browserName, matcher] of Object.entries(browserMatchers)) {
      if (matcher(userAgent))
        return `browser/${browserName}`;
    }
    return "browser/unknown";
  }
  return "unknown";
};
var shortenPackageName = (fullName) => {
  return fullName.replace("@circle-fin/", "");
};
var formatComponent = (nameWithVersion) => {
  const lastSlashIndex = nameWithVersion.lastIndexOf("/");
  if (lastSlashIndex === -1) {
    return shortenPackageName(nameWithVersion);
  }
  const name2 = nameWithVersion.substring(0, lastSlashIndex);
  const version2 = nameWithVersion.substring(lastSlashIndex + 1);
  if (name2 === "")
    return "";
  if (version2 === "")
    return shortenPackageName(name2);
  return `${shortenPackageName(name2)}/${version2}`;
};
var createRequestContext = () => {
  const context = {};
  if (typeof globalThis !== "undefined") {
    if (globalThis.__STABLECOIN_KITS_EXTERNAL_PREFIX__ !== void 0) {
      context.externalPrefix = globalThis.__STABLECOIN_KITS_EXTERNAL_PREFIX__;
    }
    if (globalThis.__STABLECOIN_KITS_CURRENT_KIT__ !== void 0) {
      context.kit = globalThis.__STABLECOIN_KITS_CURRENT_KIT__;
    }
  }
  return context;
};
var getUserAgent = (context) => {
  const ctx = createRequestContext();
  const runtime = getRuntime();
  const parts = [];
  if (ctx.externalPrefix !== void 0) {
    const formatted = formatComponent(ctx.externalPrefix);
    if (formatted)
      parts.push(formatted);
  }
  if (ctx.kit !== void 0) {
    const formatted = formatComponent(ctx.kit);
    if (formatted)
      parts.push(formatted);
  }
  parts.push(`(${runtime})`);
  return parts.join(" ");
};
var DEFAULT_CONFIG$1 = {
  timeout: 2e3,
  maxRetries: 10,
  retryDelay: 200,
  headers: {
    "Content-Type": "application/json"
  }
};
var delay = async (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
var makeApiRequest = async (url, method, isValidType, config, body) => {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
    controller.abort("Request timed out");
  }, config.timeout);
  try {
    const requestInit = {
      method,
      headers: config.headers ?? {},
      signal: controller.signal
    };
    if (body !== void 0 && ["POST", "PUT", "PATCH"].includes(method)) ;
    const response = await fetch(url, requestInit);
    clearTimeout(timeoutId);
    if (!response.ok) {
      throw new Error(`HTTP ${String(response.status)} - ${response.statusText}`);
    }
    const parsedJson = await response.json();
    if (!isValidType(parsedJson)) {
      throw new Error("Invalid response format: response data failed validation");
    }
    return parsedJson;
  } finally {
    clearTimeout(timeoutId);
  }
};
var isRetryableError = (error) => {
  if (/HTTP 4(?!(04|29))/.test(error.message)) {
    return false;
  }
  if (error.message.includes("Invalid response format")) {
    return false;
  }
  return true;
};
var pollApiWithValidation = async (url, method, isValidType, config = {}, body) => {
  const effectiveConfig = {
    ...DEFAULT_CONFIG$1,
    ...config,
    headers: {
      ...DEFAULT_CONFIG$1.headers,
      ...config.headers ?? {},
      // In browser environments, directly setting the 'User-Agent' or similar headers is restricted and may be ignored or cause errors.
      // This is why we use the 'X-User-Agent' header instead.
      ...typeof window === "undefined" ? { "User-Agent": getUserAgent() } : { "X-User-Agent": getUserAgent() }
    }
  };
  let lastError;
  for (let attempt = 1; attempt <= effectiveConfig.maxRetries; attempt++) {
    try {
      return await makeApiRequest(url, method, isValidType, effectiveConfig, body);
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      if (!isRetryableError(error)) {
        throw error;
      }
      lastError = error;
      if (attempt < effectiveConfig.maxRetries) {
        await delay(effectiveConfig.retryDelay);
      }
    }
  }
  throw new Error(`Maximum retry attempts (${String(effectiveConfig.maxRetries)}) exceeded: ${String(lastError == null ? void 0 : lastError.message)}`);
};
var pollApiGet = async (url, isValidType, config) => {
  return pollApiWithValidation(url, "GET", isValidType, config);
};
var formatUnits2 = (value, decimals) => {
  return formatUnits(value, decimals);
};
var formatAmount = (params) => {
  const { value, token } = params;
  switch (token) {
    case "USDC":
      return formatUnits2(value, 6);
    case "native":
      return formatUnits2(value, resolveChainIdentifier(params.chain).nativeCurrency.decimals);
    default:
      throw new Error(`formatAmount: Unhandled token type: ${token}`);
  }
};
var InsufficientFundsError = class _InsufficientFundsError extends Error {
  /**
   * Creates a new InsufficientFundsError.
   *
   * @param balance - The current token balance in the wallet (smallest unit).
   * @param amount - The required transaction amount (smallest unit).
   * @param token - The token ('USDC' or 'native').
   * @param tokenAddress - The contract address of the token.
   * @param chain - The blockchain network name where the transaction failed.
   */
  constructor(balance, amount, token, tokenAddress, chain) {
    const formattedBalance = formatAmount({
      value: balance,
      token,
      chain
    });
    const formattedAmount = formatAmount({
      value: amount,
      token,
      chain
    });
    const chainName = typeof chain === "object" && "name" in chain ? chain.name : chain;
    const message = `Insufficient funds for ${token} (${tokenAddress}) transaction on ${chainName}. Balance: ${formattedBalance} ${token}, is less than transaction amount: ${formattedAmount} ${token}.`;
    super(message);
    __publicField(this, "balance");
    __publicField(this, "amount");
    __publicField(this, "token");
    __publicField(this, "tokenAddress");
    __publicField(this, "chain");
    this.balance = balance;
    this.amount = amount;
    this.token = token;
    this.tokenAddress = tokenAddress;
    this.chain = chain;
    this.name = "InsufficientFundsError";
    Object.setPrototypeOf(this, _InsufficientFundsError.prototype);
  }
};
var ValidationError = class extends Error {
  constructor(message, errors) {
    super(message);
    __publicField(this, "errors");
    this.errors = errors;
    this.name = "ValidationError";
  }
};
var formatZodError = (error) => {
  const path = error.path.length > 0 ? `${error.path.join(".")}: ` : "";
  return `${path}${error.message}`;
};
function validate(value, schema, context) {
  const result = schema.safeParse(value);
  if (!result.success) {
    const errors = result.error.errors.map(formatZodError);
    const firstError = errors[0] ?? "Invalid value";
    throw new ValidationError(`Invalid ${context}: ${firstError}`, errors);
  }
}
var VALIDATION_STATE = Symbol("validationState");
function validateWithStateTracking(value, schema, context, validatorName) {
  if (value === null) {
    throw new ValidationError(`Invalid ${context}: Value is null`, [
      `Value is null`
    ]);
  }
  if (value === void 0) {
    throw new ValidationError(`Invalid ${context}: Value is undefined`, [
      `Value is undefined`
    ]);
  }
  if (typeof value !== "object") {
    throw new ValidationError(`Invalid ${context}: Value must be an object`, [
      `Value must be an object, got ${typeof value}`
    ]);
  }
  const valueWithState = value;
  const state = valueWithState[VALIDATION_STATE] ?? { validatedBy: [] };
  if (state.validatedBy.includes(validatorName)) {
    return;
  }
  validate(value, schema, context);
  state.validatedBy.push(validatorName);
  valueWithState[VALIDATION_STATE] = state;
}
var chainDefinitionSchema = external_exports.object({
  name: external_exports.string({
    required_error: "Chain name is required",
    invalid_type_error: "Chain name must be a string"
  }).min(1, "Chain name cannot be empty"),
  explorerUrl: external_exports.string({
    required_error: "Explorer URL template is required",
    invalid_type_error: "Explorer URL template must be a string"
  }).min(1, "Explorer URL template cannot be empty").refine((url) => url.includes("{hash}"), "Explorer URL template must contain a {hash} placeholder")
});
var transactionHashSchema = external_exports.string({
  required_error: "Transaction hash is required",
  invalid_type_error: "Transaction hash must be a string"
}).min(1, "Transaction hash cannot be empty").transform((hash) => hash.trim()).refine((hash) => hash.length > 0, "Transaction hash must not be empty or whitespace-only");
var buildExplorerUrlParamsSchema = external_exports.object({
  chainDef: chainDefinitionSchema,
  txHash: transactionHashSchema
});
var explorerUrlSchema = external_exports.string().url("Generated explorer URL is invalid");
function validateOrThrow(value, schema, message) {
  const result = schema.safeParse(value);
  if (!result.success) {
    const errors = result.error.errors.map((error) => {
      const path = error.path.length > 0 ? `${error.path.join(".")}: ` : "";
      return `${path}${error.message}`;
    });
    const firstError = errors[0];
    const errorMessage = firstError !== void 0 ? `${message}: ${firstError}` : message;
    throw new ValidationError(errorMessage, errors);
  }
}
var detectFormat = (address) => {
  if (/^0x[0-9a-fA-F]{40}$/.test(address)) {
    return "evm";
  }
  if (/^0x[0-9a-fA-F]{64}$/.test(address)) {
    return "bytes32";
  }
  const decoded = esm_default.decode(address);
  if (decoded.length === 32)
    return "solana";
  throw new Error(`Unsupported address format: ${address}`);
};
var toBytes32 = (address) => {
  const fmt = detectFormat(address);
  switch (fmt) {
    case "evm":
      return hexZeroPad(address, 32);
    case "bytes32":
      return address;
    case "solana":
      return hexlify(esm_default.decode(address));
  }
  throw new Error(`Unsupported address format: ${address}`);
};
var bytes32ToEvm = (bytes32) => {
  const hex = bytes32.startsWith("0x") ? bytes32.slice(2) : bytes32;
  const ethHex = "0x" + hex.slice(-40);
  return getAddress(ethHex);
};
function bytes32ToSolana(bytes32) {
  const hex = bytes32.startsWith("0x") ? bytes32.slice(2) : bytes32;
  const buffer = import_buffer.Buffer.from(hex, "hex");
  return esm_default.encode(new Uint8Array(buffer));
}
var convertAddress = (address, targetFormat) => {
  const current = detectFormat(address);
  if (current === targetFormat)
    return address;
  const asBytes32 = toBytes32(address);
  switch (targetFormat) {
    case "bytes32":
      return asBytes32;
    case "evm":
      return bytes32ToEvm(asBytes32);
    case "solana":
      return bytes32ToSolana(asBytes32);
  }
  throw new Error(`Unsupported address format: ${address}`);
};
function buildExplorerUrl(chainDef, txHash) {
  validateOrThrow({ chainDef, txHash }, buildExplorerUrlParamsSchema, "Invalid buildExplorerUrl parameters");
  const { chainDef: validChainDef, txHash: validTxHash } = buildExplorerUrlParamsSchema.parse({ chainDef, txHash });
  const explorerUrl = validChainDef.explorerUrl.replace(/{hash}/g, validTxHash);
  validate(explorerUrl, explorerUrlSchema, "explorer URL");
  return explorerUrl;
}
var TransferSpeed;
(function(TransferSpeed3) {
  TransferSpeed3["FAST"] = "FAST";
  TransferSpeed3["SLOW"] = "SLOW";
})(TransferSpeed || (TransferSpeed = {}));
var createDecimalStringValidator = (options) => (schema) => schema.regex(/^\d+(?:[.,]\d{3})*(?:[.,]\d+)?$/, options.regexMessage).superRefine((val, ctx) => {
  const lastSeparator = val.lastIndexOf(",");
  const lastDot = val.lastIndexOf(".");
  const isCommaSeparated = lastSeparator > lastDot;
  const normalizedValue = val.replace(isCommaSeparated ? /\./g : /,/g, "").replace(isCommaSeparated ? "," : ".", ".");
  const amount = parseFloat(normalizedValue);
  if (Number.isNaN(amount)) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: options.regexMessage
    });
    return;
  }
  if (options.maxDecimals !== void 0) {
    const decimalPart = normalizedValue.split(".")[1];
    if (decimalPart && decimalPart.length > options.maxDecimals) {
      ctx.addIssue({
        code: external_exports.ZodIssueCode.custom,
        message: `Maximum supported decimal places: ${options.maxDecimals.toString()}`
      });
      return;
    }
  }
  if (options.allowZero && amount < 0) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: `${options.attributeName} must be non-negative`
    });
  } else if (!options.allowZero && amount <= 0) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: `${options.attributeName} must be greater than 0`
    });
  }
});
external_exports.object({
  name: external_exports.string().min(1, "Chain name is required"),
  type: external_exports.string().min(1, "Chain type is required")
});
var walletContextSchema = external_exports.object({
  adapter: external_exports.object({
    prepare: external_exports.function().returns(external_exports.any()),
    waitForTransaction: external_exports.function().returns(external_exports.any())
  }),
  address: external_exports.string().min(1),
  chain: external_exports.object({
    name: external_exports.string(),
    type: external_exports.string(),
    isTestnet: external_exports.boolean()
  })
});
var customFeeSchema = external_exports.object({
  /**
   * The fee to charge for the transfer as string.
   * Must be a non-negative value.
   */
  value: createDecimalStringValidator({
    allowZero: true,
    regexMessage: "Value must be non-negative",
    attributeName: "value"
  })(external_exports.string()).optional(),
  /**
   * The fee recipient address.
   * Must be a valid address string.
   */
  recipientAddress: external_exports.string().trim().min(1, "Fee recipient must be a non-empty string").optional()
}).strict();
var bridgeParamsSchema = external_exports.object({
  amount: external_exports.string().min(1, "Required").pipe(createDecimalStringValidator({
    allowZero: false,
    regexMessage: "Amount must be a numeric string with optional decimal places (e.g., 10.5, 10,5, 1.000,50 or 1,000.50)",
    attributeName: "amount",
    maxDecimals: 6
  })(external_exports.string())),
  source: walletContextSchema,
  destination: walletContextSchema,
  token: external_exports.literal("USDC"),
  config: external_exports.object({
    transferSpeed: external_exports.nativeEnum(TransferSpeed).optional(),
    maxFee: external_exports.string().pipe(createDecimalStringValidator({
      allowZero: true,
      regexMessage: 'maxFee must be a numeric string with optional decimal places (e.g., "1", "0.5", "1.5")',
      attributeName: "maxFee",
      maxDecimals: 6
    })(external_exports.string())).optional(),
    customFee: customFeeSchema.optional()
  })
});
var isBurnFeeTier = (item) => {
  return typeof item === "object" && item !== null && "finalityThreshold" in item && "minimumFee" in item && typeof item.finalityThreshold === "number" && (typeof item.minimumFee === "string" || typeof item.minimumFee === "number");
};
var isFastBurnFeeResponse = (data) => {
  if (!Array.isArray(data)) {
    return false;
  }
  return data.every(isBurnFeeTier);
};
function buildFastBurnFeeUrl(sourceDomain, destinationDomain, isTestnet) {
  const baseUrl = isTestnet ? "https://iris-api-sandbox.circle.com" : "https://iris-api.circle.com";
  return `${baseUrl}/v2/burn/USDC/fees/${sourceDomain.toString()}/${destinationDomain.toString()}`;
}
var FAST_TIER_FINALITY_THRESHOLD = 1e3;
async function fetchUsdcFastBurnFee(sourceDomain, destinationDomain, isTestnet) {
  if (!Number.isInteger(sourceDomain) || sourceDomain < 0) {
    throw new Error("Invalid source domain: must be a non-negative integer");
  }
  if (!Number.isInteger(destinationDomain) || destinationDomain < 0) {
    throw new Error("Invalid destination domain: must be a non-negative integer");
  }
  const url = buildFastBurnFeeUrl(sourceDomain, destinationDomain, isTestnet);
  const response = await pollApiGet(url, isFastBurnFeeResponse, DEFAULT_CONFIG$1);
  if (response.length === 0) {
    throw new Error("No fee tiers available in API response");
  }
  const feeTiers = response;
  const fastTier = feeTiers.find((tier) => tier.finalityThreshold === FAST_TIER_FINALITY_THRESHOLD);
  if (!fastTier) {
    throw new Error(`No fast tier (finalityThreshold: ${FAST_TIER_FINALITY_THRESHOLD.toString()}) available in API response`);
  }
  let minimumFee;
  try {
    minimumFee = BigInt(fastTier.minimumFee);
  } catch {
    throw new Error(`Invalid minimumFee value: cannot convert "${String(fastTier.minimumFee)}" to bigint`);
  }
  if (minimumFee < 0n) {
    throw new Error("Invalid minimumFee: value must be non-negative");
  }
  return minimumFee;
}
var DEPOSIT_FOR_BURN_GAS_ESTIMATE_EVM = 169914n;
var CUSTOM_BURN_GAS_ESTIMATE_EVM = 201525n;
var RECEIVE_MESSAGE_GAS_ESTIMATE_EVM = 237401n;
var CCTPv2MinFinalityThreshold = {
  [TransferSpeed.FAST]: 1e3,
  [TransferSpeed.SLOW]: 2e3
};
var DEFAULT_CONFIG = {
  timeout: 2e3,
  // 2 seconds
  maxRetries: 30 * 20,
  // 30 * 20 * 2 seconds (from the retry delay) = 20 minutes (to account for slow transfers maximum time based on confirmations)
  retryDelay: 2e3,
  // 2 seconds
  headers: {
    "Content-Type": "application/json"
  }
};
var isValidAttestationMessage = (obj) => {
  return typeof obj === "object" && obj !== null && "message" in obj && "eventNonce" in obj && "attestation" in obj && "decodedMessage" in obj && "cctpVersion" in obj && "status" in obj && typeof obj.status === "string";
};
var isCompleteAttestation = (message) => {
  return message.status === "complete";
};
var hasValidAttestationStructure = (obj) => {
  if (typeof obj !== "object" || obj === null || !("messages" in obj) || !Array.isArray(obj.messages)) {
    return false;
  }
  const messages = obj.messages;
  return messages.every(isValidAttestationMessage);
};
var isAttestationResponse = (obj) => {
  if (!hasValidAttestationStructure(obj)) {
    throw new Error("Invalid attestation response structure");
  }
  if (!obj.messages.some(isCompleteAttestation)) {
    throw new Error("Attestation not ready");
  }
  return true;
};
var buildIrisUrl = (sourceDomainId, transactionHash, isTestnet) => {
  const baseUrl = isTestnet ? "https://iris-api-sandbox.circle.com" : "https://iris-api.circle.com";
  const url = new URL(`${baseUrl}/v2/messages/${String(sourceDomainId)}`);
  url.searchParams.set("transactionHash", transactionHash);
  return url.toString();
};
var fetchAttestation = async (sourceDomainId, transactionHash, isTestnet, config = {}) => {
  const url = buildIrisUrl(sourceDomainId, transactionHash, isTestnet);
  const effectiveConfig = { ...DEFAULT_CONFIG, ...config };
  return await pollApiGet(url, isAttestationResponse, effectiveConfig);
};
var assertCCTPv2WalletContextSymbol = Symbol("assertCCTPv2WalletContext");
function assertCCTPv2WalletContext(params) {
  validateWithStateTracking(params, walletContextSchema, "CCTPv2 wallet context", assertCCTPv2WalletContextSymbol);
  const context = params;
  if (context.chain.usdcAddress === null) {
    throw new ValidationError(`Invalid CCTPv2 wallet context: Chain ${context.chain.name} does not have USDC configured.`, [`Chain must have USDC configured`]);
  }
  if (!isCCTPV2Supported(context.chain)) {
    throw new ValidationError(`Invalid CCTPv2 wallet context: Chain ${context.chain.name} does not support CCTPv2`, [`Chain must support CCTPv2`]);
  }
}
var RECOVERABILITY_VALUES = [
  "RETRYABLE",
  "RESUMABLE",
  "FATAL"
];
var RECOVERABILITY_ARRAY = [...RECOVERABILITY_VALUES];
var errorDetailsSchema = external_exports.object({
  /** Numeric identifier following standardized ranges (1000+ for INPUT errors) */
  code: external_exports.number().int("Error code must be an integer").min(1e3, "Error code must be within valid range (1000+)").max(1099, "Error code must be within valid range (1099 max)"),
  /** Human-readable ID (e.g., "NETWORK_MISMATCH") */
  name: external_exports.string().min(1, "Error name must be a non-empty string").regex(/^[A-Z_][A-Z0-9_]*$/, "Error name must match pattern: ^[A-Z_][A-Z0-9_]*$"),
  /** Error handling strategy */
  recoverability: external_exports.enum(RECOVERABILITY_ARRAY, {
    errorMap: () => ({
      message: "Recoverability must be one of: RETRYABLE, RESUMABLE, FATAL"
    })
  }),
  /** User-friendly explanation with network context */
  message: external_exports.string().min(1, "Error message must be a non-empty string").max(500, "Error message must be 500 characters or less"),
  /** Raw error details, context, or the original error that caused this one. */
  cause: external_exports.object({
    /** Free-form error payload from underlying system */
    trace: external_exports.unknown().optional()
  }).optional()
});
function validateErrorDetails(details) {
  const result = errorDetailsSchema.safeParse(details);
  if (!result.success) {
    const issues = result.error.issues.map((issue) => `${issue.path.join(".")}: ${issue.message}`).join(", ");
    throw new TypeError(`Invalid ErrorDetails: ${issues}`);
  }
  return result.data;
}
var KitError = class extends Error {
  /**
   * Create a new KitError instance.
   *
   * @param details - The error details object containing all required properties.
   * @throws \{TypeError\} When details parameter is missing or invalid.
   */
  constructor(details) {
    const validatedDetails = validateErrorDetails(details);
    super(validatedDetails.message);
    /** Numeric identifier following standardized ranges (1000+ for INPUT errors) */
    __publicField(this, "code");
    /** Human-readable ID (e.g., "NETWORK_MISMATCH") */
    __publicField(this, "name");
    /** Error handling strategy */
    __publicField(this, "recoverability");
    /** Raw error details, context, or the original error that caused this one. */
    __publicField(this, "cause");
    Object.defineProperties(this, {
      name: {
        value: validatedDetails.name,
        writable: false,
        enumerable: true,
        configurable: false
      },
      code: {
        value: validatedDetails.code,
        writable: false,
        enumerable: true,
        configurable: false
      },
      recoverability: {
        value: validatedDetails.recoverability,
        writable: false,
        enumerable: true,
        configurable: false
      },
      ...validatedDetails.cause && {
        cause: {
          value: validatedDetails.cause,
          writable: false,
          enumerable: true,
          configurable: false
        }
      }
    });
  }
};
var InputError = {
  /** Network type mismatch between chains (mainnet vs testnet) */
  NETWORK_MISMATCH: {
    code: 1001,
    name: "INPUT_NETWORK_MISMATCH"
  },
  /** Unsupported or invalid bridge route configuration */
  UNSUPPORTED_ROUTE: {
    code: 1003,
    name: "INPUT_UNSUPPORTED_ROUTE"
  },
  /** General validation failure for complex validation rules */
  VALIDATION_FAILED: {
    code: 1098,
    name: "INPUT_VALIDATION_FAILED"
  }
};
function createNetworkMismatchError(sourceChain, destChain) {
  const sourceNetworkType = sourceChain.isTestnet ? "testnet" : "mainnet";
  const destNetworkType = destChain.isTestnet ? "testnet" : "mainnet";
  const errorDetails = {
    ...InputError.NETWORK_MISMATCH,
    recoverability: "FATAL",
    message: `Cannot bridge between ${sourceChain.name} (${sourceNetworkType}) and ${destChain.name} (${destNetworkType}). Source and destination networks must both be testnet or both be mainnet.`,
    cause: {
      trace: { sourceChain: sourceChain.name, destChain: destChain.name }
    }
  };
  return new KitError(errorDetails);
}
function createUnsupportedRouteError(source, destination) {
  const errorDetails = {
    ...InputError.UNSUPPORTED_ROUTE,
    recoverability: "FATAL",
    message: `Route from ${source} to ${destination} is not supported.`,
    cause: {
      trace: { source, destination }
    }
  };
  return new KitError(errorDetails);
}
function createValidationFailedError(field, value, reason) {
  let valueString;
  if (typeof value === "string") {
    valueString = `'${value}'`;
  } else if (typeof value === "object" && value !== null) {
    valueString = JSON.stringify(value);
  } else {
    valueString = String(value);
  }
  const errorDetails = {
    ...InputError.VALIDATION_FAILED,
    recoverability: "FATAL",
    message: `Validation failed for '${field}': ${valueString} - ${reason}.`,
    cause: {
      trace: { field, value, reason }
    }
  };
  return new KitError(errorDetails);
}
var assertCCTPv2BridgeParamsSymbol = Symbol("assertCCTPv2BridgeParams");
function assertCCTPv2BridgeParams(params) {
  var _a, _b, _c, _d;
  validateWithStateTracking(params, bridgeParamsSchema, "CCTPv2 bridge parameters", assertCCTPv2BridgeParamsSymbol);
  const bridgeParams = params;
  if (bridgeParams.source.chain.isTestnet !== bridgeParams.destination.chain.isTestnet) {
    throw createNetworkMismatchError(bridgeParams.source.chain, bridgeParams.destination.chain);
  }
  assertCCTPV2Support(bridgeParams.source.chain, bridgeParams.destination.chain);
  if (((_b = (_a = bridgeParams.config) == null ? void 0 : _a.customFee) == null ? void 0 : _b.value) !== void 0 && ((_d = (_c = bridgeParams.config) == null ? void 0 : _c.customFee) == null ? void 0 : _d.recipientAddress) === void 0) {
    throw createValidationFailedError("recipientAddress", bridgeParams.config.customFee.value, "Custom fee is defined but fee recipient is not. Please provide a fee recipient.");
  }
  assertCCTPv2WalletContext(bridgeParams.source);
  assertCCTPv2WalletContext(bridgeParams.destination);
}
function assertCCTPV2Support(source, destination) {
  if (!isCCTPV2Supported(source) || !isCCTPV2Supported(destination)) {
    throw createUnsupportedRouteError(source.name, destination.name);
  }
}
var getMintRecipientAccount = async (chainType, rawAddress, mintAddress) => {
  if (chainType === "evm") {
    return rawAddress;
  } else {
    try {
      const [{ PublicKey }, { getAssociatedTokenAddressSync }] = await Promise.all([
        import("./index.browser.esm-PMPNERI6.js"),
        import("./esm-3RZ6XQDQ.js")
      ]);
      const owner = new PublicKey(rawAddress);
      const mintPub = new PublicKey(mintAddress);
      const ata = getAssociatedTokenAddressSync(mintPub, owner);
      return ata.toBase58();
    } catch {
      throw new Error("Failed to derive Solana token account. Please ensure @solana/web3.js and @solana/spl-token are installed: npm install @solana/web3.js @solana/spl-token");
    }
  }
};
function checkFieldMismatch(field, decoded, param, errors) {
  if (decoded !== param) {
    errors.push(`${field} mismatch: decoded=${String(decoded)}, params=${String(param)}`);
  }
}
async function assertCCTPv2AttestationParams(attestation, params) {
  var _a;
  const errors = [];
  const message = attestation.decodedMessage;
  const messageBody = message.decodedMessageBody;
  const destinationAddressForMint = params.destination.recipientAddress ?? params.destination.address;
  const mintRecipient = await getMintRecipientAccount(params.destination.chain.type, destinationAddressForMint, params.destination.chain.usdcAddress);
  let sender;
  if (hasCustomContractSupport(params.source.chain, "bridge")) {
    if (params.source.chain.type === "solana") {
      sender = params.source.address;
    } else {
      sender = (_a = params.source.chain.kitContracts) == null ? void 0 : _a.bridge;
    }
  } else {
    sender = params.source.address;
  }
  checkFieldMismatch("sourceDomain", message.sourceDomain, params.source.chain.cctp.domain.toString(), errors);
  checkFieldMismatch("destinationDomain", message.destinationDomain, params.destination.chain.cctp.domain.toString(), errors);
  checkFieldMismatch("minFinalityThreshold", message.minFinalityThreshold, CCTPv2MinFinalityThreshold[params.config.transferSpeed ?? "FAST"].toString(), errors);
  checkFieldMismatch("sender", params.source.chain.type === "evm" ? messageBody.messageSender.toLowerCase() : messageBody.messageSender, params.source.chain.type === "evm" ? sender == null ? void 0 : sender.toLowerCase() : sender, errors);
  checkFieldMismatch("recipient", params.destination.chain.type === "evm" ? messageBody.mintRecipient.toLowerCase() : messageBody.mintRecipient, params.destination.chain.type === "evm" ? mintRecipient.toLowerCase() : mintRecipient, errors);
  checkFieldMismatch("amount", messageBody.amount, params.amount.toString(), errors);
  checkFieldMismatch("burnToken", messageBody.burnToken.toLowerCase(), params.source.chain.usdcAddress.toLowerCase(), errors);
  if (errors.length > 0) {
    throw new ValidationError("Attestation validation failed: received attestation does not match expected transfer parameters", errors);
  }
}
async function executePreparedChainRequest({ name: name2, request, adapter, chain, confirmations = 1, timeout }) {
  const step = { name: name2, state: "pending" };
  try {
    if (request.type === "noop") {
      step.state = "noop";
      return step;
    }
    const txHash = await request.execute();
    step.txHash = txHash;
    const transaction = await adapter.waitForTransaction(txHash, {
      confirmations,
      timeout
    }, chain);
    step.state = transaction.blockNumber ? "success" : "error";
    step.data = transaction;
    step.explorerUrl = buildExplorerUrl(chain, txHash);
    if (!transaction.blockNumber) {
      step.errorMessage = "Transaction was not confirmed on-chain.";
    }
  } catch (err) {
    step.state = "error";
    step.error = err;
    if (err instanceof Error) {
      step.errorMessage = err.message;
    } else if (typeof err === "object" && err != null && "message" in err) {
      step.errorMessage = String(err.message);
    } else {
      step.errorMessage = "Unknown error occurred during approval step.";
    }
  }
  return step;
}
async function bridgeApproval({ params, provider }) {
  var _a, _b;
  const customFee = BigInt(((_b = (_a = params.config) == null ? void 0 : _a.customFee) == null ? void 0 : _b.value) ?? "0");
  const amountBigInt = BigInt(params.amount);
  const approvalAmount = (amountBigInt + customFee).toString();
  return await executePreparedChainRequest({
    name: "approve",
    adapter: params.source.adapter,
    chain: params.source.chain,
    request: await provider.approve(params.source, approvalAmount)
  });
}
async function bridgeBurn({ params, provider }) {
  return await executePreparedChainRequest({
    name: "burn",
    adapter: params.source.adapter,
    chain: params.source.chain,
    request: await provider.burn(params)
  });
}
async function bridgeFetchAttestation({ params, provider }, txHash) {
  var _a;
  let step = {
    name: "fetchAttestation",
    state: "pending"
  };
  try {
    const apiPollingConfig = ((_a = params.config) == null ? void 0 : _a.transferSpeed) === TransferSpeed.SLOW && params.source.chain.cctp.contracts.v2.confirmations > 20 ? { retryDelay: 3e4 } : void 0;
    const attestation = await provider.fetchAttestation(params.source, txHash, apiPollingConfig);
    step = {
      ...step,
      state: "success",
      data: attestation
    };
  } catch (err) {
    let errorMessage = "Unknown attestation error";
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === "string") {
      errorMessage = err;
    }
    step = {
      ...step,
      state: "error",
      error: err,
      errorMessage,
      data: void 0
    };
  }
  return step;
}
async function bridgeMint({ params, provider }, attestation) {
  await assertCCTPv2AttestationParams(attestation, params);
  return await executePreparedChainRequest({
    name: "mint",
    adapter: params.destination.adapter,
    chain: params.destination.chain,
    request: await provider.mint(params.source, params.destination, attestation)
  });
}
var mockAttestationMessage = {
  attestation: "0x8bd9b9e63eb05128eb2896b63e3e1df39bfd6bbfb893b69dc53c39252aeb85df1ded70263b07da17abf88e6e1b77f16ebcdb4eb1c6b4ea4c625215e5cb9dddb81bffe0b9d75e2094f05e48f18f70d0b254999bde90bab26f5c0da29b2d7e00feca1cfed119cba0d2a0e887648a40e803e0ca34aa8fd94ce068515eeaef72b520aa1b",
  message: "0x000000010000000000000006f446cb82eb486fef485c14c301eaab73aa35f87e3feda3547acf0f33cd4b40f30000000000000000000000008fe6b999dc680ccfdd5bf7eb0974218be2542daa0000000000000000000000008fe6b999dc680ccfdd5bf7eb0974218be2542daa0000000000000000000000000000000000000000000000000000000000000000000003e8000003e8000000010000000000000000000000001c7d4b196cb0c7b01d743fbc6116a902379c723800000000000000000000000023f9a5bea7b92a0638520607407bc7f0310aeed400000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000c5567a5e3370d4dbfb0540025078e283e36a363d000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000001f6b158",
  eventNonce: "0xf446cb82eb486fef485c14c301eaab73aa35f87e3feda3547acf0f33cd4b40f3",
  cctpVersion: 2,
  status: "complete",
  decodedMessage: {
    sourceDomain: "0",
    destinationDomain: "6",
    nonce: "0xf446cb82eb486fef485c14c301eaab73aa35f87e3feda3547acf0f33cd4b40f3",
    sender: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
    recipient: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
    destinationCaller: "0x0000000000000000000000000000000000000000000000000000000000000000",
    minFinalityThreshold: "1000",
    finalityThresholdExecuted: "1000",
    messageBody: "0x000000010000000000000000000000001c7d4b196cb0c7b01d743fbc6116a902379c723800000000000000000000000023f9a5bea7b92a0638520607407bc7f0310aeed400000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000c5567a5e3370d4dbfb0540025078e283e36a363d000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000001f6b158",
    decodedMessageBody: {
      burnToken: "0x1c7d4b196cb0c7b01d743fbc6116a902379c7238",
      mintRecipient: "0x23f9a5bea7b92a0638520607407bc7f0310aeed4",
      amount: "100000",
      messageSender: "0xc5567a5e3370d4dbfb0540025078e283e36a363d",
      maxFee: "11",
      feeExecuted: "10",
      expirationBlock: "32944472",
      hookData: null
    }
  },
  delayReason: null
};
var stepExecutors = [
  {
    name: "approve",
    executor: async (params, provider) => bridgeApproval({ params, provider })
  },
  {
    name: "burn",
    executor: async (params, provider) => bridgeBurn({ params, provider }),
    updateContext: (step) => {
      if (!step.txHash) {
        throw new Error("Burn step completed but no transaction hash was returned");
      }
      return {
        burnTxHash: step.txHash
      };
    }
  },
  {
    name: "fetchAttestation",
    executor: async (params, provider, context) => {
      if (!(context == null ? void 0 : context.burnTxHash)) {
        throw new Error("Burn transaction hash not available for attestation");
      }
      return bridgeFetchAttestation({ params, provider }, context.burnTxHash);
    },
    updateContext: (step) => {
      if (!step.data) {
        throw new Error("Attestation step completed but no data was returned");
      }
      return {
        attestationData: step.data
      };
    }
  },
  {
    name: "mint",
    executor: async (params, provider, context) => {
      if (!(context == null ? void 0 : context.attestationData)) {
        throw new Error("Attestation data not available for minting");
      }
      return bridgeMint({ params, provider }, context.attestationData);
    }
  }
];
function handleStepError(stepName, error, result) {
  result.state = "error";
  let errorMessage;
  if (error instanceof Error) {
    errorMessage = error.message;
  } else if (typeof error === "string") {
    errorMessage = error;
  } else if (typeof error === "object" && error != null && "message" in error) {
    errorMessage = error.message;
  } else {
    errorMessage = `Unknown error occurred during ${stepName.toLowerCase()} step.`;
  }
  result.steps.push({
    name: stepName,
    state: "error",
    error,
    errorMessage
  });
}
function dispatchStepEvent(name2, step, provider) {
  if (!provider.actionDispatcher) {
    return;
  }
  const actionValues = {
    protocol: "cctp",
    version: "v2",
    values: step
  };
  switch (name2) {
    case "approve":
    case "burn":
    case "mint":
      provider.actionDispatcher.dispatch(name2, {
        ...actionValues,
        method: name2
      });
      break;
    case "fetchAttestation":
      provider.actionDispatcher.dispatch(name2, {
        ...actionValues,
        method: name2,
        values: step
      });
      break;
  }
}
async function bridge(params, provider) {
  const result = {
    state: "pending",
    amount: params.amount,
    token: params.token,
    source: {
      address: params.source.address,
      chain: params.source.chain
    },
    destination: {
      address: params.destination.address,
      chain: params.destination.chain
    },
    steps: [],
    config: params.config,
    provider: provider.name
  };
  let context = void 0;
  for (const { name: name2, executor, updateContext } of stepExecutors) {
    try {
      const step = await executor(params, provider, context);
      if (step.state === "error") {
        let fallbackErrorMessage = "Unknown error";
        if (step.error instanceof Error) {
          fallbackErrorMessage = step.error.message;
        } else if (typeof step.error === "string") {
          fallbackErrorMessage = step.error;
        }
        const errorDetails = step.errorMessage ?? fallbackErrorMessage;
        throw new Error(`${name2} step failed: ${errorDetails}`);
      }
      context = updateContext == null ? void 0 : updateContext(step);
      dispatchStepEvent(name2, step, provider);
      result.steps.push(step);
    } catch (error) {
      handleStepError(name2, error, result);
      return result;
    }
  }
  result.state = "success";
  return result;
}
async function resolveOperationContext(adapter, ctx) {
  if (adapter.capabilities === void 0) {
    throw new Error("Adapter capabilities must be defined. Please ensure the adapter implements the capabilities property.");
  }
  if (ctx === void 0) {
    throw new Error("Operation context is required. Please provide a context with the required chain and address information.");
  }
  const resolvedChain = resolveChainIdentifier(ctx.chain);
  let resolvedAddress;
  if (adapter.capabilities.addressContext === "developer-controlled") {
    if (!ctx.address) {
      throw new Error("Address is required for developer-controlled adapters. Please provide an address in the operation context.");
    }
    resolvedAddress = ctx.address;
  } else {
    try {
      resolvedAddress = await adapter.getAddress(resolvedChain);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to resolve address from user-controlled adapter: ${message}`);
    }
  }
  return {
    chain: resolvedChain,
    address: resolvedAddress
  };
}
var hexStringSchema = external_exports.string().min(1, "Hex string is required").refine((value) => value.trim().length > 0, "Hex string cannot be empty").refine((value) => value.startsWith("0x"), "Hex string must start with 0x prefix").refine((value) => {
  const hexPattern = /^0x[0-9a-fA-F]+$/;
  return hexPattern.test(value);
}, "Hex string contains invalid characters. Only hexadecimal characters (0-9, a-f, A-F) are allowed after 0x");
hexStringSchema.refine((value) => value.length === 42, "EVM address must be exactly 42 characters long (0x + 40 hex characters)");
hexStringSchema.refine((value) => value.length === 66, "Transaction hash must be exactly 66 characters long (0x + 64 hex characters)");
var base58StringSchema = external_exports.string().min(1, "Base58 string is required").refine((value) => value.trim().length > 0, "Base58 string cannot be empty").refine((value) => {
  const base58Pattern = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;
  return base58Pattern.test(value);
}, "Base58 string contains invalid characters. Only base58 characters (1-9, A-H, J-N, P-Z, a-k, m-z) are allowed");
base58StringSchema.refine((value) => value.length >= 32 && value.length <= 44, "Solana address must be between 32-44 characters long (base58-encoded 32-byte address)");
base58StringSchema.refine((value) => value.length >= 86 && value.length <= 88, "Solana transaction hash must be between 86-88 characters long (base58-encoded 64-byte signature)");
external_exports.object({
  prepare: external_exports.function(),
  waitForTransaction: external_exports.function(),
  getAddress: external_exports.function()
});
var validateBalanceForTransaction = async (params) => {
  const { amount, adapter, token, tokenAddress, operationContext } = params;
  const balancePrepared = await adapter.prepareAction("usdc.balanceOf", {
    walletAddress: operationContext.address
  }, operationContext);
  const balance = await balancePrepared.execute();
  if (BigInt(balance) < BigInt(amount)) {
    throw new InsufficientFundsError(balance.toString(), amount, token, tokenAddress, operationContext.chain);
  }
};
var CCTPv2StepName = {
  approve: "approve",
  burn: "burn",
  fetchAttestation: "fetchAttestation",
  mint: "mint"
};
var STEP_TRANSITION_RULES = {
  // Starting state - no steps executed yet
  "": [
    {
      condition: () => true,
      nextStep: CCTPv2StepName.approve,
      reason: "Start with approval step",
      isActionable: true
    }
  ],
  // After Approve step
  [CCTPv2StepName.approve]: [
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "success";
      },
      nextStep: CCTPv2StepName.burn,
      reason: "Approval successful, proceed to burn",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "error";
      },
      nextStep: CCTPv2StepName.approve,
      reason: "Retry failed approval",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "noop";
      },
      nextStep: CCTPv2StepName.burn,
      reason: "No approval needed, proceed to burn",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "pending";
      },
      nextStep: CCTPv2StepName.approve,
      reason: "Continue pending approval",
      isActionable: false
      // Waiting for pending transaction
    }
  ],
  // After Burn step
  [CCTPv2StepName.burn]: [
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "success";
      },
      nextStep: CCTPv2StepName.fetchAttestation,
      reason: "Burn successful, fetch attestation",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "error";
      },
      nextStep: CCTPv2StepName.burn,
      reason: "Retry failed burn",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "pending";
      },
      nextStep: CCTPv2StepName.burn,
      reason: "Continue pending burn",
      isActionable: false
      // Waiting for pending transaction
    }
  ],
  // After FetchAttestation step
  [CCTPv2StepName.fetchAttestation]: [
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "success";
      },
      nextStep: CCTPv2StepName.mint,
      reason: "Attestation fetched, proceed to mint",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "error";
      },
      nextStep: CCTPv2StepName.fetchAttestation,
      reason: "Retry fetching attestation",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "pending";
      },
      nextStep: CCTPv2StepName.fetchAttestation,
      reason: "Continue pending attestation fetch",
      isActionable: false
      // Waiting for attestation to be ready
    }
  ],
  // After Mint step
  [CCTPv2StepName.mint]: [
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "success";
      },
      nextStep: null,
      reason: "Bridge completed successfully",
      isActionable: false
      // Nothing more to do
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "error";
      },
      nextStep: CCTPv2StepName.mint,
      reason: "Retry failed mint",
      isActionable: true
    },
    {
      condition: (ctx) => {
        var _a;
        return ((_a = ctx.lastStep) == null ? void 0 : _a.state) === "pending";
      },
      nextStep: CCTPv2StepName.mint,
      reason: "Continue pending mint",
      isActionable: false
      // Waiting for pending transaction
    }
  ]
};
var analyzeSteps = (bridgeResult) => {
  if (!bridgeResult || !Array.isArray(bridgeResult.steps)) {
    throw new Error("Invalid bridgeResult: must contain a steps array");
  }
  const { steps } = bridgeResult;
  const context = buildFlowContext(steps);
  const continuation = determineContinuationFromRules(context);
  return {
    continuationStep: continuation.nextStep,
    isActionable: continuation.isActionable,
    completedSteps: Array.from(context.completedSteps),
    failedSteps: Array.from(context.failedSteps),
    reason: continuation.reason
  };
};
function buildFlowContext(steps) {
  const completedSteps = /* @__PURE__ */ new Set();
  const failedSteps = /* @__PURE__ */ new Set();
  let lastStep;
  for (const step of steps) {
    if (step.state === "success" || step.state === "noop") {
      completedSteps.add(step.name);
    } else if (step.state === "error") {
      failedSteps.add(step.name);
    }
    lastStep = {
      name: step.name,
      state: step.state
    };
  }
  return {
    completedSteps,
    failedSteps,
    ...lastStep && { lastStep }
  };
}
function determineContinuationFromRules(context) {
  var _a;
  const lastStepName = (_a = context.lastStep) == null ? void 0 : _a.name;
  if (lastStepName === void 0) {
    const rules2 = STEP_TRANSITION_RULES[""];
    const matchingRule2 = rules2 == null ? void 0 : rules2.find((rule) => rule.condition(context));
    if (!matchingRule2) {
      return {
        nextStep: null,
        isActionable: false,
        reason: "No initial state rule found"
      };
    }
    return {
      nextStep: matchingRule2.nextStep,
      isActionable: matchingRule2.isActionable,
      reason: matchingRule2.reason
    };
  }
  if (lastStepName === "") {
    return {
      nextStep: null,
      isActionable: false,
      reason: "No transition rules defined for step with empty name"
    };
  }
  const rules = STEP_TRANSITION_RULES[lastStepName];
  if (!rules) {
    return {
      nextStep: null,
      isActionable: false,
      reason: `No transition rules defined for step: ${lastStepName}`
    };
  }
  const matchingRule = rules.find((rule) => rule.condition(context));
  if (!matchingRule) {
    return {
      nextStep: null,
      isActionable: false,
      reason: `No matching transition rule for current context`
    };
  }
  return {
    nextStep: matchingRule.nextStep,
    isActionable: matchingRule.isActionable,
    reason: matchingRule.reason
  };
}
function populateContext(result) {
  var _a, _b;
  return {
    burnTxHash: (_a = result.steps.find((step) => step.name === "burn")) == null ? void 0 : _a.txHash,
    attestationData: (_b = result.steps.find((step) => step.name === "fetchAttestation")) == null ? void 0 : _b.data
  };
}
async function retry(result, context, provider) {
  const analysis = analyzeSteps(result);
  if (!analysis.isActionable) {
    throw new Error("Retry not supported for this result, requires user action");
  }
  if (!isCCTPV2Supported(result.source.chain)) {
    throw new Error(`Source chain ${result.source.chain.name} does not support CCTP v2`);
  }
  if (!isCCTPV2Supported(result.destination.chain)) {
    throw new Error(`Destination chain ${result.destination.chain.name} does not support CCTP v2`);
  }
  const params = {
    ...result,
    source: {
      ...result.source,
      adapter: context.from,
      chain: result.source.chain
    },
    destination: {
      ...result.destination,
      adapter: context.to,
      chain: result.destination.chain
    },
    config: result.config ?? {}
  };
  const indexOfSteps = stepExecutors.findIndex((step) => step.name === analysis.continuationStep);
  if (indexOfSteps === -1) {
    throw new Error(`Continuation step ${analysis.continuationStep ?? ""} not found`);
  }
  let stepContext = populateContext(result);
  for (const { name: name2, executor, updateContext } of stepExecutors.slice(indexOfSteps)) {
    try {
      const step = await executor(params, provider, stepContext);
      if (step.state === "error") {
        const errorMessage = step.errorMessage ?? `${name2} step returned error state`;
        throw new Error(errorMessage);
      }
      stepContext = updateContext == null ? void 0 : updateContext(step);
      dispatchStepEvent(name2, step, provider);
      result.steps.push(step);
    } catch (error) {
      handleStepError(name2, error, result);
      return result;
    }
  }
  result.state = "success";
  return result;
}
var SUPPORTED_CHAINS = Object.values(Chains).filter((chain) => isCCTPV2Supported(chain));
var CCTPV2BridgingProvider = class extends BridgingProvider {
  /**
   * Creates a new instance of the CCTP v2 bridging provider.
   *
   * @param config - Optional configuration overrides for the provider
   */
  constructor(config = {}) {
    super();
    /** The name of the provider */
    __publicField(this, "name", "CCTPV2BridgingProvider");
    /**
     * The chains that this provider supports.
     */
    __publicField(this, "supportedChains", SUPPORTED_CHAINS);
    /**
     * The provider's configuration.
     */
    __publicField(this, "config");
    this.config = config;
  }
  /**
   * Execute a cross-chain USDC bridge operation using the CCTP v2 protocol.
   *
   * This method orchestrates the complete CCTP v2 bridge flow including validation,
   * token approval, burning on source chain, attestation retrieval, and minting on
   * destination chain. The process is atomic and will revert if any step fails.
   *
   * This method performs the full CCTP v2 bridge flow by validating parameters and delegating
   * to the core bridge logic. It handles token approval, burning, attestation fetching, and minting.
   *
   * The bridge operation consists of these sequential steps:
   * 1. **Approval**: Approve USDC spending (if needed)
   * 2. **Burn**: Burn USDC on source chain
   * 3. **Attestation**: Fetch attestation from Circle's API
   * 4. **Mint**: Mint USDC on destination chain
   *
   * @param params - The bridge parameters containing source, destination, amount, and optional config.
   * @returns A promise resolving to the bridge result, including transaction details, step states, and explorer URLs.
   * @throws {ValidationError} When the parameters are invalid.
   * @throws {BridgeError} When the bridge operation fails.
   * @throws {UnsupportedRouteError} When the route is not supported.
   *
   * @example
   * ```typescript
   * const result = await provider.bridge({
   *   source: { adapter: sourceAdapter, chain: 'Ethereum' },
   *   destination: { adapter: destAdapter, chain: 'Base' },
   *   amount: '10.50',
   *   token: 'USDC',
   *   config: { transferSpeed: 'FAST' }
   * })
   *
   * console.log('Bridge completed!')
   * console.log('Source tx:', result.steps.burn.transactionHash)
   * console.log('Destination tx:', result.steps.mint.transactionHash)
   * ```
   */
  async bridge(params) {
    assertCCTPv2BridgeParams(params);
    const { source, amount, token } = params;
    const operationContext = this.extractOperationContext(source);
    await validateBalanceForTransaction({
      adapter: source.adapter,
      amount,
      token,
      tokenAddress: source.chain.usdcAddress,
      operationContext
    });
    return bridge(params, this);
  }
  /**
   * Retry a failed or incomplete CCTP v2 bridge operation.
   *
   * Analyzes the bridge result to determine where to continue and executes
   * remaining steps from that point. Handles transaction failures, network
   * issues, and incomplete multi-step flows.
   *
   * @param result - The bridge result containing step history and current state.
   * @param context - The retry context with fresh adapter instances.
   * @returns Updated bridge result after retry execution.
   *
   * @throws Error when the result is not actionable or retry fails.
   *
   * @example
   * ```typescript
   * const retryResult = await provider.retry(failedResult, retryContext)
   * ```
   */
  async retry(result, context) {
    return retry(result, context, this);
  }
  /**
   * Estimate the cost and fees for a CCTP v2 cross-chain bridge operation.
   *
   * This method validates parameters and calculates the expected gas and protocol fees for a bridge
   * operation without executing it. The estimation includes gas costs for both source and destination
   * chains, as well as any applicable protocol fees.
   *
   * @param params - The bridge parameters containing source, destination, amount, and optional config.
   * @returns Promise resolving to detailed cost breakdown including:
   *          - `gasFees`: Array of gas estimates for each step (Approve, Burn, Mint)
   *            - Gas amounts in native token smallest units (wei for ETH, lamports for SOL, etc.)
   *          - `fees`: Array of protocol and kit fees
   *            - Provider fees in USDC decimal units (e.g., "0.1" USDC)
   *            - Kit fees in USDC decimal units if configured
   * @throws {ValidationError} When the parameters are invalid.
   * @throws {UnsupportedRouteError} When the route is not supported.
   *
   * @example
   * ```typescript
   * const estimate = await provider.estimate({
   *   source: { adapter: sourceAdapter, chain: 'Ethereum' },
   *   destination: { adapter: destAdapter, chain: 'Base' },
   *   amount: '10.50',
   *   token: 'USDC'
   * })
   *
   * console.log('Total cost:', estimate.totalCost)
   * console.log('Source gas:', estimate.sourceGas)
   * console.log('Destination gas:', estimate.destinationGas)
   * ```
   */
  async estimate(params) {
    var _a, _b, _c, _d;
    assertCCTPv2BridgeParams(params);
    const { source, destination, amount } = params;
    const estimateBurn = async () => {
      const burn = await this.burn(params);
      return await burn.estimate(void 0, await source.adapter.calculateTransactionFee(hasCustomContractSupport(source.chain, "bridge") ? CUSTOM_BURN_GAS_ESTIMATE_EVM : DEPOSIT_FOR_BURN_GAS_ESTIMATE_EVM, void 0, source.chain));
    };
    const estimateMint = async () => {
      const mint = await this.mint(source, destination, mockAttestationMessage);
      return await mint.estimate(void 0, await destination.adapter.calculateTransactionFee(RECEIVE_MESSAGE_GAS_ESTIMATE_EVM, void 0, destination.chain));
    };
    const [approveEstimate, depositForBurnFee, receiveMessageFee, maxFee] = await Promise.allSettled([
      this.approve(source, amount).then(async (approve) => approve.estimate()),
      estimateBurn(),
      estimateMint(),
      ((_a = params.config) == null ? void 0 : _a.transferSpeed) === void 0 || ((_b = params.config) == null ? void 0 : _b.transferSpeed) === TransferSpeed.FAST ? this.getMaxFee(params) : Promise.resolve(0n)
    ]);
    const estimateResult = {
      gasFees: [],
      fees: []
    };
    this.addGasFeeEstimate(estimateResult, approveEstimate, "Approve", source);
    this.addGasFeeEstimate(estimateResult, depositForBurnFee, "Burn", source);
    this.addGasFeeEstimate(estimateResult, receiveMessageFee, "Mint", destination);
    this.addProviderFeeEstimate(estimateResult, maxFee);
    this.addKitFeeEstimate(estimateResult, (_d = (_c = params.config) == null ? void 0 : _c.customFee) == null ? void 0 : _d.value);
    return estimateResult;
  }
  /**
   * Extracts OperationContext from bridge parameters for a given wallet context.
   *
   * This method extracts the chain and address information from the wallet context
   * to construct an OperationContext for use with adapter method calls.
   *
   * @param walletContext - The wallet context to extract operation context from
   * @returns The operation context with chain and address information
   */
  extractOperationContext(walletContext) {
    return {
      chain: walletContext.chain,
      address: walletContext.address
    };
  }
  /**
   * Helper method to add gas fee estimates to the result.
   */
  addGasFeeEstimate(result, estimate, name2, walletContext) {
    try {
      if (estimate.status === "fulfilled") {
        const formattedFee = formatUnits2(estimate.value.fee, walletContext.chain.nativeCurrency.decimals);
        result.gasFees.push({
          name: name2,
          token: walletContext.chain.nativeCurrency.symbol,
          blockchain: walletContext.chain.chain,
          fees: {
            gas: estimate.value.gas,
            gasPrice: estimate.value.gasPrice,
            fee: formattedFee
          }
        });
      } else {
        throw new Error(estimate.reason);
      }
    } catch (err) {
      result.gasFees.push({
        name: name2,
        token: walletContext.chain.nativeCurrency.symbol,
        blockchain: walletContext.chain.chain,
        fees: null,
        error: err
      });
    }
  }
  /**
   * Helper method to add provider fee estimates to the result.
   */
  addProviderFeeEstimate(result, maxFeeEstimate) {
    try {
      if (maxFeeEstimate.status === "fulfilled") {
        const formattedMaxFee = formatUnits2(String(maxFeeEstimate.value), 6);
        result.fees.push({
          type: "provider",
          token: "USDC",
          amount: formattedMaxFee
        });
      } else {
        throw new Error(maxFeeEstimate.reason);
      }
    } catch (err) {
      result.fees.push({
        type: "provider",
        token: "USDC",
        amount: null,
        error: err
      });
    }
  }
  /**
   * Helper method to add kit fee to the result.
   */
  addKitFeeEstimate(result, customFee) {
    try {
      if (customFee && BigInt(customFee) > 0n) {
        const formattedCustomFee = formatUnits2(customFee, 6);
        result.fees.push({
          type: "kit",
          token: "USDC",
          amount: formattedCustomFee
        });
      }
    } catch (err) {
      result.fees.push({
        type: "kit",
        token: "USDC",
        amount: null,
        error: err
      });
    }
  }
  /**
   * Prepares a USDC token approval transaction for CCTP v2 transfers.
   *
   * This method creates a prepared transaction that approves the CCTP v2 contract
   * to spend a specified amount of USDC tokens. The approval is required before
   * initiating a cross-chain burn operation.
   *
   * @param adapter - The adapter for transaction preparation and execution
   * @param amount - The amount of USDC to approve (as string to avoid precision issues)
   * @returns Promise resolving to a prepared chain request ready for gas estimation and execution
   *
   * @throws Error when adapter is not provided
   * @throws Error when amount is invalid (empty, negative, or malformed)
   * @throws Error when chain does not support CCTP v2
   * @throws Error when chain does not have USDC configured
   * @throws Error when CCTP v2 contracts are missing or misconfigured
   *
   * @example
   * ```typescript
   * const provider = new CCTPV2BridgingProvider()
   * const prepared = await provider.approve(adapter, '1000000') // 1 USDC (6 decimals)
   *
   * // Estimate gas cost
   * const gasEstimate = await prepared.estimate()
   * console.log('Gas required:', gasEstimate.gas)
   *
   * // Execute the approval
   * const txHash = await prepared.execute()
   * console.log('Approval transaction:', txHash)
   * ```
   */
  async approve(source, amount) {
    assertCCTPv2WalletContext(source);
    const { chain, adapter } = source;
    const operationContext = this.extractOperationContext(source);
    let resolvedContext;
    try {
      resolvedContext = await resolveOperationContext(adapter, operationContext);
    } catch (error) {
      throw new Error(`Failed to resolve operation context: ${error instanceof Error ? error.message : String(error)}`);
    }
    const spenderAddress = resolveCCTPV2ContractAddress(chain);
    const actionParams = {
      amount: BigInt(amount),
      delegate: spenderAddress,
      chain: (resolvedContext == null ? void 0 : resolvedContext.chain) ?? chain
    };
    return await adapter.prepareAction("usdc.increaseAllowance", actionParams, resolvedContext);
  }
  /**
   * Prepares a CCTP v2 token minting transaction on the destination chain.
   *
   * This method creates a prepared transaction that calls the receiveMessage function
   * on the CCTP v2 MessageTransmitter contract to finalize the cross-chain transfer.
   * It's used to mint tokens on the destination chain after a successful burn operation
   * on the source chain.
   *
   * @param adapter - The adapter for transaction preparation and execution
   * @param messageBytes - The encoded message bytes from the source chain burn transaction
   * @param attestation - The attestation signature from Circle proving the burn happened
   * @returns Promise resolving to a prepared chain request ready for gas estimation and execution
   *
   * @throws Error when adapter is not provided
   * @throws Error when messageBytes is invalid (empty or malformed)
   * @throws Error when attestation is invalid (empty or malformed)
   * @throws Error when chain does not support CCTP v2
   * @throws Error when CCTP v2 contracts are missing or misconfigured
   *
   * @example
   * ```typescript
   * const provider = new CCTPV2BridgingProvider()
   * const prepared = await provider.mint(
   *   destAdapter,
   *   '0x1234...', // message bytes from burn transaction
   *   '0xabcd...'  // attestation from Circle
   * )
   *
   * // Estimate gas cost
   * const gasEstimate = await prepared.estimate()
   * console.log('Gas required:', gasEstimate.gas)
   *
   * // Execute the mint transaction
   * const txHash = await prepared.execute()
   * console.log('Mint transaction:', txHash)
   * ```
   */
  async mint(source, destination, attestation) {
    assertCCTPv2WalletContext(source);
    assertCCTPv2WalletContext(destination);
    const operationContext = this.extractOperationContext(destination);
    const destinationAddressForMint = destination.recipientAddress ?? destination.address;
    const actionParams = {
      fromChain: source.chain,
      toChain: destination.chain,
      message: attestation.message,
      attestation: attestation.attestation,
      eventNonce: attestation.eventNonce,
      destinationAddress: destinationAddressForMint
    };
    return await destination.adapter.prepareAction("cctp.v2.receiveMessage", actionParams, operationContext);
  }
  /**
   * Fetches attestation data for a burn transaction from the IRIS API.
   *
   * This method retrieves the attestation data required to complete a mint operation
   * after a successful burn. It includes retry logic and timeout handling to ensure
   * reliable attestation fetching.
   *
   * @param sourceDomainId - The CCTP domain ID of the source chain
   * @param transactionHash - The transaction hash of the burn operation
   * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
   * @param config - Optional configuration overrides for this specific request
   * @returns Promise resolving to the first attestation message
   * @throws Error If no attestation is found for the transaction
   * @throws Error If the request times out after retries
   * @throws Error If the IRIS API returns an error response
   * @throws Error If the response format is invalid
   *
   * @example
   * ```typescript
   * const provider = new CCTPV2BridgingProvider({
   *   attestation: { maxRetries: 5 } // Global config
   * })
   *
   * try {
   *   // Use global config for mainnet
   *   const result1 = await provider.fetchAttestation(1, '0x123...', false)
   *
   *   // Override for this specific call on testnet
   *   const result2 = await provider.fetchAttestation(1, '0x456...', true, {
   *     timeout: 5000 // Override just the timeout
   *   })
   * } catch (error) {
   *   if (error.message.includes('No attestation found')) {
   *     // Handle missing attestation
   *   } else if (error.message.includes('Request timed out')) {
   *     // Handle timeout
   *   } else if (error.message.includes('HTTP 4')) {
   *     // Handle API error
   *   } else {
   *     // Handle other errors
   *   }
   * }
   * ```
   */
  async fetchAttestation(source, transactionHash, config) {
    var _a;
    assertCCTPv2WalletContext(source);
    try {
      const effectiveConfig = {
        ...(_a = this.config) == null ? void 0 : _a.attestation,
        ...config
      };
      const response = await fetchAttestation(source.chain.cctp.domain, transactionHash, source.chain.isTestnet, effectiveConfig);
      const message = response.messages[0];
      if (!message) {
        throw new Error("Failed to fetch attestation: No attestation found for the given transaction");
      }
      return message;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      if (!error.message.startsWith("Failed to fetch attestation")) {
        throw new Error(`Failed to fetch attestation: ${error.message}`);
      }
      throw error;
    }
  }
  /**
   * Checks if both source and destination chains support CCTP v2 transfers.
   *
   * This method validates that both chains have CCTP v2 contracts deployed and configured.
   * It uses the `isCCTPV2Supported` guard function to check each chain individually.
   *
   * @param source - The source chain definition to check for CCTP v2 support
   * @param destination - The destination chain definition to check for CCTP v2 support
   * @returns `true` if both chains support CCTP v2, `false` otherwise
   *
   * @example
   * ```typescript
   * const provider = new CCTPV2BridgingProvider()
   * const canTransfer = provider.supportsRoute(Ethereum, Base)
   *
   * if (canTransfer) {
   *   console.log('CCTP v2 transfer is supported between these chains')
   * } else {
   *   console.log('One or both chains do not support CCTP v2')
   * }
   * ```
   */
  supportsRoute(source, destination, token) {
    if (source.chain === destination.chain) {
      return false;
    }
    if (source.isTestnet !== destination.isTestnet) {
      return false;
    }
    if (token === "USDC") {
      return isCCTPV2Supported(source) && isCCTPV2Supported(destination);
    }
    return false;
  }
  /**
   * Determines the appropriate maximum fee for a cross-chain bridge operation.
   *
   * For FAST bridge operations, it calculates a dynamic fee based on the bridge amount
   * and fast bridge burn fee, or uses a provided maxFee if specified.
   *
   * For SLOW bridge operations, it returns 0 as there are no additional fees.
   *
   * @param params - The bridge parameters object containing:
   *   - `source`: The source wallet context with chain definition and adapter
   *   - `destination`: The destination wallet context with chain definition and adapter
   *   - `amount`: The bridge amount in minor units (e.g., "1000000" for 1 USDC)
   *   - `config`: Optional bridge configuration including transferSpeed and maxFee settings.
   *     When used via BridgeKit, fee values are automatically converted from human-readable
   *     format (e.g., "1") to smallest units (e.g., "1000000").
   * @returns The maximum fee to be used for the bridge operation in minor units
   *
   * @example
   * ```typescript
   * const maxFee = await provider.getMaxFee({
   *   source: { adapter: sourceAdapter, chain: Chains.Ethereum, address: '0x...' },
   *   destination: { adapter: destAdapter, chain: Chains.Base, address: '0x...' },
   *   amount: '1000000', // 1 USDC in minor units
   *   token: 'USDC',
   *   config: {
   *     transferSpeed: TransferSpeed.FAST,
   *     maxFee: '1000000' // Provider receives values in smallest units
   *   }
   * })
   * console.log('Max fee:', maxFee)
   * ```
   */
  async getMaxFee(params) {
    assertCCTPv2BridgeParams(params);
    const { source, destination, amount, config } = params;
    const transferSpeed = (config == null ? void 0 : config.transferSpeed) ?? TransferSpeed.FAST;
    let maxFee;
    if (transferSpeed === TransferSpeed.SLOW) {
      maxFee = 0n;
    } else if ((config == null ? void 0 : config.maxFee) === void 0) {
      const baseFeeInBps = await fetchUsdcFastBurnFee(source.chain.cctp.domain, destination.chain.cctp.domain, source.chain.isTestnet);
      const amountInMinorUnits = BigInt(amount);
      const baseFee = (baseFeeInBps * amountInMinorUnits + 9999n) / 10000n;
      maxFee = baseFee + baseFee / 10n;
    } else {
      maxFee = BigInt(config.maxFee);
    }
    return maxFee;
  }
  /**
   * Prepares a CCTP v2 burn operation to initiate a cross-chain bridge operation.
   *
   * This method creates the necessary transaction data for burning USDC tokens on the source
   * chain as part of the CCTP v2 bridge flow. The burn operation locks the tokens and emits
   * a message that can be used to mint equivalent tokens on the destination chain.
   *
   * @param params - The bridge parameters including source, destination, amount, and config
   * @returns Promise resolving to the prepared burn transaction data
   *
   * @example
   * ```typescript
   * const preparedBurn = await provider.burn(
   *   {
   *     source: { adapter, chain: "Ethereum_Sepolia" },
   *     destination: { adapter, chain: "Base_Sepolia" },
   *     amount: '1000000', // 1 USDC
   *     token: 'USDC',
   *     config: { transferSpeed: 'FAST' }
   *   }
   * )
   * await preparedBurn.execute()
   * ```
   */
  async burn(params) {
    assertCCTPv2BridgeParams(params);
    const { source, destination, amount, config } = params;
    const transferSpeed = (config == null ? void 0 : config.transferSpeed) ?? TransferSpeed.FAST;
    const minFinalityThreshold = CCTPv2MinFinalityThreshold[transferSpeed];
    const destinationAddressForMint = destination.recipientAddress ?? destination.address;
    const [maxFee, mintRecipient] = await Promise.all([
      this.getMaxFee(params),
      getMintRecipientAccount(destination.chain.type, destinationAddressForMint, destination.chain.usdcAddress)
    ]);
    const actionParams = {
      fromChain: source.chain,
      toChain: destination.chain,
      amount: BigInt(amount),
      mintRecipient: convertAddress(mintRecipient, "bytes32"),
      maxFee,
      minFinalityThreshold
    };
    const { recipientAddress, value } = params.config.customFee ?? {};
    const protocolFee = value ? BigInt(value) : void 0;
    const operationContext = this.extractOperationContext(source);
    let resolvedContext;
    try {
      resolvedContext = await resolveOperationContext(source.adapter, operationContext);
    } catch (error) {
      throw new Error(`Failed to resolve operation context: ${error instanceof Error ? error.message : String(error)}`);
    }
    const useCustomBurn = hasCustomContractSupport(source.chain, "bridge");
    const actionType = useCustomBurn ? "cctp.v2.customBurn" : "cctp.v2.depositForBurn";
    const finalParams = useCustomBurn ? { ...actionParams, feeRecipient: recipientAddress, protocolFee } : actionParams;
    return await source.adapter.prepareAction(actionType, finalParams, resolvedContext);
  }
  /**
   * Waits for a transaction to be mined and confirmed on the blockchain.
   *
   * This method should block until the transaction is confirmed on the blockchain.
   *
   * @param adapter - The adapter to use for transaction waiting
   * @param txHash - The hash of the transaction to wait for
   * @param chain - The chain definition where the transaction was executed
   * @param config - Optional configuration for transaction waiting (confirmations, timeout)
   * @returns The hash of the confirmed transaction
   * @example
   * ```typescript
   * const provider = new CCTPV2BridgingProvider()
   * const txHash = await provider.waitForTransaction(
   *   adapter,
   *   '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
   *   Ethereum,
   * )
   * console.log('Transaction confirmed:', txHash)
   * ```
   */
  async waitForTransaction(adapter, txHash, chain, config) {
    return adapter.waitForTransaction(txHash, config, chain);
  }
};

// node_modules/@circle-fin/bridge-kit/index.mjs
var setExternalPrefix = (prefix) => {
  if (typeof globalThis !== "undefined") {
    globalThis.__STABLECOIN_KITS_EXTERNAL_PREFIX__ = prefix;
  }
};
var registerKit = (kitIdentifier) => {
  if (typeof globalThis !== "undefined") {
    globalThis.__STABLECOIN_KITS_CURRENT_KIT__ = kitIdentifier;
  }
};
var Blockchain2;
(function(Blockchain3) {
  Blockchain3["Algorand"] = "Algorand";
  Blockchain3["Algorand_Testnet"] = "Algorand_Testnet";
  Blockchain3["Aptos"] = "Aptos";
  Blockchain3["Aptos_Testnet"] = "Aptos_Testnet";
  Blockchain3["Arc_Testnet"] = "Arc_Testnet";
  Blockchain3["Arbitrum"] = "Arbitrum";
  Blockchain3["Arbitrum_Sepolia"] = "Arbitrum_Sepolia";
  Blockchain3["Avalanche"] = "Avalanche";
  Blockchain3["Avalanche_Fuji"] = "Avalanche_Fuji";
  Blockchain3["Base"] = "Base";
  Blockchain3["Base_Sepolia"] = "Base_Sepolia";
  Blockchain3["Celo"] = "Celo";
  Blockchain3["Celo_Alfajores_Testnet"] = "Celo_Alfajores_Testnet";
  Blockchain3["Codex"] = "Codex";
  Blockchain3["Codex_Testnet"] = "Codex_Testnet";
  Blockchain3["Ethereum"] = "Ethereum";
  Blockchain3["Ethereum_Sepolia"] = "Ethereum_Sepolia";
  Blockchain3["Hedera"] = "Hedera";
  Blockchain3["Hedera_Testnet"] = "Hedera_Testnet";
  Blockchain3["HyperEVM"] = "HyperEVM";
  Blockchain3["HyperEVM_Testnet"] = "HyperEVM_Testnet";
  Blockchain3["Ink"] = "Ink";
  Blockchain3["Ink_Testnet"] = "Ink_Testnet";
  Blockchain3["Linea"] = "Linea";
  Blockchain3["Linea_Sepolia"] = "Linea_Sepolia";
  Blockchain3["NEAR"] = "NEAR";
  Blockchain3["NEAR_Testnet"] = "NEAR_Testnet";
  Blockchain3["Noble"] = "Noble";
  Blockchain3["Noble_Testnet"] = "Noble_Testnet";
  Blockchain3["Optimism"] = "Optimism";
  Blockchain3["Optimism_Sepolia"] = "Optimism_Sepolia";
  Blockchain3["Polkadot_Asset_Hub"] = "Polkadot_Asset_Hub";
  Blockchain3["Polkadot_Westmint"] = "Polkadot_Westmint";
  Blockchain3["Plume"] = "Plume";
  Blockchain3["Plume_Testnet"] = "Plume_Testnet";
  Blockchain3["Polygon"] = "Polygon";
  Blockchain3["Polygon_Amoy_Testnet"] = "Polygon_Amoy_Testnet";
  Blockchain3["Sei"] = "Sei";
  Blockchain3["Sei_Testnet"] = "Sei_Testnet";
  Blockchain3["Solana"] = "Solana";
  Blockchain3["Solana_Devnet"] = "Solana_Devnet";
  Blockchain3["Sonic"] = "Sonic";
  Blockchain3["Sonic_Testnet"] = "Sonic_Testnet";
  Blockchain3["Stellar"] = "Stellar";
  Blockchain3["Stellar_Testnet"] = "Stellar_Testnet";
  Blockchain3["Sui"] = "Sui";
  Blockchain3["Sui_Testnet"] = "Sui_Testnet";
  Blockchain3["Unichain"] = "Unichain";
  Blockchain3["Unichain_Sepolia"] = "Unichain_Sepolia";
  Blockchain3["World_Chain"] = "World_Chain";
  Blockchain3["World_Chain_Sepolia"] = "World_Chain_Sepolia";
  Blockchain3["XDC"] = "XDC";
  Blockchain3["XDC_Apothem"] = "XDC_Apothem";
  Blockchain3["ZKSync_Era"] = "ZKSync_Era";
  Blockchain3["ZKSync_Sepolia"] = "ZKSync_Sepolia";
})(Blockchain2 || (Blockchain2 = {}));
function defineChain2(chain) {
  return chain;
}
var Algorand2 = defineChain2({
  type: "algorand",
  chain: Blockchain2.Algorand,
  name: "Algorand",
  title: "Algorand Mainnet",
  nativeCurrency: {
    name: "Algo",
    symbol: "ALGO",
    decimals: 6
  },
  isTestnet: false,
  explorerUrl: "https://explorer.perawallet.app/tx/{hash}",
  rpcEndpoints: ["https://mainnet-api.algonode.cloud"],
  eurcAddress: null,
  usdcAddress: "31566704",
  cctp: null
});
var AlgorandTestnet2 = defineChain2({
  type: "algorand",
  chain: Blockchain2.Algorand_Testnet,
  name: "Algorand Testnet",
  title: "Algorand Test Network",
  nativeCurrency: {
    name: "Algo",
    symbol: "ALGO",
    decimals: 6
  },
  isTestnet: true,
  explorerUrl: "https://testnet.explorer.perawallet.app/tx/{hash}",
  rpcEndpoints: ["https://testnet-api.algonode.cloud"],
  eurcAddress: null,
  usdcAddress: "10458941",
  cctp: null
});
var Aptos2 = defineChain2({
  type: "aptos",
  chain: Blockchain2.Aptos,
  name: "Aptos",
  title: "Aptos Mainnet",
  nativeCurrency: {
    name: "Aptos",
    symbol: "APT",
    decimals: 8
  },
  isTestnet: false,
  explorerUrl: "https://explorer.aptoslabs.com/txn/{hash}?network=mainnet",
  rpcEndpoints: ["https://fullnode.mainnet.aptoslabs.com/v1"],
  eurcAddress: null,
  usdcAddress: "0xbae207659db88bea0cbead6da0ed00aac12edcdda169e591cd41c94180b46f3b",
  cctp: {
    domain: 9,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9bce6734f7b63e835108e3bd8c36743d4709fe435f44791918801d0989640a9d",
        messageTransmitter: "0x177e17751820e4b4371873ca8c30279be63bdea63b88ed0f2239c2eea10f1772",
        confirmations: 1
      }
    }
  }
});
var AptosTestnet2 = defineChain2({
  type: "aptos",
  chain: Blockchain2.Aptos_Testnet,
  name: "Aptos Testnet",
  title: "Aptos Test Network",
  nativeCurrency: {
    name: "Aptos",
    symbol: "APT",
    decimals: 8
  },
  isTestnet: true,
  explorerUrl: "https://explorer.aptoslabs.com/txn/{hash}?network=testnet",
  rpcEndpoints: ["https://fullnode.testnet.aptoslabs.com/v1"],
  eurcAddress: null,
  usdcAddress: "0x69091fbab5f7d635ee7ac5098cf0c1efbe31d68fec0f2cd565e8d168daf52832",
  cctp: {
    domain: 9,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x5f9b937419dda90aa06c1836b7847f65bbbe3f1217567758dc2488be31a477b9",
        messageTransmitter: "0x081e86cebf457a0c6004f35bd648a2794698f52e0dde09a48619dcd3d4cc23d9",
        confirmations: 1
      }
    }
  }
});
var BRIDGE_CONTRACT_EVM_TESTNET2 = "0xC5567a5E3370d4DBfB0540025078e283e36A363d";
var BRIDGE_CONTRACT_EVM_MAINNET2 = "0xB3FA262d0fB521cc93bE83d87b322b8A23DAf3F0";
var ArcTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Arc_Testnet,
  name: "Arc Testnet",
  title: "ArcTestnet",
  nativeCurrency: {
    name: "Arc",
    symbol: "Arc",
    decimals: 18
  },
  chainId: 5042002,
  isTestnet: true,
  explorerUrl: "https://testnet.arcscan.app/tx/{hash}",
  rpcEndpoints: ["https://rpc.testnet.arc.network/"],
  eurcAddress: "0x89B50855Aa3bE2F677cD6303Cec089B5F319D72a",
  usdcAddress: "0x3600000000000000000000000000000000000000",
  cctp: {
    domain: 26,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Arbitrum2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Arbitrum,
  name: "Arbitrum",
  title: "Arbitrum Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 42161,
  isTestnet: false,
  explorerUrl: "https://arbiscan.io/tx/{hash}",
  rpcEndpoints: ["https://arb1.arbitrum.io/rpc"],
  eurcAddress: null,
  usdcAddress: "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
  cctp: {
    domain: 3,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x19330d10D9Cc8751218eaf51E8885D058642E08A",
        messageTransmitter: "0xC30362313FBBA5cf9163F0bb16a0e01f01A896ca",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var ArbitrumSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Arbitrum_Sepolia,
  name: "Arbitrum Sepolia",
  title: "Arbitrum Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 421614,
  isTestnet: true,
  explorerUrl: "https://sepolia.arbiscan.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia-rollup.arbitrum.io/rpc"],
  eurcAddress: null,
  usdcAddress: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
  cctp: {
    domain: 3,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0xaCF1ceeF35caAc005e15888dDb8A3515C41B4872",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Avalanche2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Avalanche,
  name: "Avalanche",
  title: "Avalanche Mainnet",
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  chainId: 43114,
  isTestnet: false,
  explorerUrl: "https://subnets.avax.network/c-chain/tx/{hash}",
  rpcEndpoints: ["https://api.avax.network/ext/bc/C/rpc"],
  eurcAddress: "0xc891eb4cbdeff6e073e859e987815ed1505c2acd",
  usdcAddress: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
  cctp: {
    domain: 1,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x6b25532e1060ce10cc3b0a99e5683b91bfde6982",
        messageTransmitter: "0x8186359af5f57fbb40c6b14a588d2a59c0c29880",
        confirmations: 1
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var AvalancheFuji2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Avalanche_Fuji,
  name: "Avalanche Fuji",
  title: "Avalanche Fuji Testnet",
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  chainId: 43113,
  isTestnet: true,
  explorerUrl: "https://subnets-test.avax.network/c-chain/tx/{hash}",
  eurcAddress: "0x5e44db7996c682e92a960b65ac713a54ad815c6b",
  usdcAddress: "0x5425890298aed601595a70ab815c96711a31bc65",
  cctp: {
    domain: 1,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0xeb08f243e5d3fcff26a9e38ae5520a669f4019d0",
        messageTransmitter: "0xa9fb1b3009dcb79e2fe346c16a604b8fa8ae0a79",
        confirmations: 1
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  rpcEndpoints: ["https://api.avax-test.network/ext/bc/C/rpc"],
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Base2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Base,
  name: "Base",
  title: "Base Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 8453,
  isTestnet: false,
  explorerUrl: "https://basescan.org/tx/{hash}",
  rpcEndpoints: ["https://mainnet.base.org", "https://base.publicnode.com"],
  eurcAddress: "0x60a3e35cc302bfa44cb288bc5a4f316fdb1adb42",
  usdcAddress: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
  cctp: {
    domain: 6,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x1682Ae6375C4E4A97e4B583BC394c861A46D8962",
        messageTransmitter: "0xAD09780d193884d503182aD4588450C416D6F9D4",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var BaseSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Base_Sepolia,
  name: "Base Sepolia",
  title: "Base Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 84532,
  isTestnet: true,
  explorerUrl: "https://sepolia.basescan.org/tx/{hash}",
  rpcEndpoints: ["https://sepolia.base.org"],
  eurcAddress: "0x808456652fdb597867f38412077A9182bf77359F",
  usdcAddress: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  cctp: {
    domain: 6,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Celo2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Celo,
  name: "Celo",
  title: "Celo Mainnet",
  nativeCurrency: {
    name: "Celo",
    symbol: "CELO",
    decimals: 18
  },
  chainId: 42220,
  isTestnet: false,
  explorerUrl: "https://celoscan.io/tx/{hash}",
  rpcEndpoints: ["https://forno.celo.org"],
  eurcAddress: null,
  usdcAddress: "0xcebA9300f2b948710d2653dD7B07f33A8B32118C",
  cctp: null
});
var CeloAlfajoresTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Celo_Alfajores_Testnet,
  name: "Celo Alfajores",
  title: "Celo Alfajores Testnet",
  nativeCurrency: {
    name: "Celo",
    symbol: "CELO",
    decimals: 18
  },
  chainId: 44787,
  isTestnet: true,
  explorerUrl: "https://alfajores.celoscan.io/tx/{hash}",
  rpcEndpoints: ["https://alfajores-forno.celo-testnet.org"],
  eurcAddress: null,
  usdcAddress: "0x2F25deB3848C207fc8E0c34035B3Ba7fC157602B",
  cctp: null
});
var Codex2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Codex,
  name: "Codex Mainnet",
  title: "Codex Mainnet",
  nativeCurrency: {
    name: "ETH",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 81224,
  isTestnet: false,
  explorerUrl: "https://explorer.codex.xyz/tx/{hash}",
  rpcEndpoints: ["https://rpc.codex.xyz"],
  eurcAddress: null,
  usdcAddress: "0xd996633a415985DBd7D6D12f4A4343E31f5037cf",
  cctp: {
    domain: 12,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var CodexTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Codex_Testnet,
  name: "Codex Testnet",
  title: "Codex Testnet",
  nativeCurrency: {
    name: "ETH",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 812242,
  isTestnet: true,
  explorerUrl: "https://explorer.codex-stg.xyz/tx/{hash}",
  rpcEndpoints: ["https://rpc.codex-stg.xyz"],
  eurcAddress: null,
  usdcAddress: "0x6d7f141b6819C2c9CC2f818e6ad549E7Ca090F8f",
  cctp: {
    domain: 12,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Ethereum2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Ethereum,
  name: "Ethereum",
  title: "Ethereum Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 1,
  isTestnet: false,
  explorerUrl: "https://etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://eth.merkle.io", "https://ethereum.publicnode.com"],
  eurcAddress: "0x1aBaEA1f7C830bD89Acc67eC4af516284b1bC33c",
  usdcAddress: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  cctp: {
    domain: 0,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0xbd3fa81b58ba92a82136038b25adec7066af3155",
        messageTransmitter: "0x0a992d191deec32afe36203ad87d7d289a738f81",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 2
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var EthereumSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Ethereum_Sepolia,
  name: "Ethereum Sepolia",
  title: "Ethereum Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 11155111,
  isTestnet: true,
  explorerUrl: "https://sepolia.etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia.drpc.org"],
  eurcAddress: "0x08210F9170F89Ab7658F0B5E3fF39b0E03C594D4",
  usdcAddress: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
  cctp: {
    domain: 0,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 2
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Hedera2 = defineChain2({
  type: "hedera",
  chain: Blockchain2.Hedera,
  name: "Hedera",
  title: "Hedera Mainnet",
  nativeCurrency: {
    name: "HBAR",
    symbol: "HBAR",
    decimals: 18
  },
  isTestnet: false,
  explorerUrl: "https://hashscan.io/mainnet/transaction/{hash}",
  // Note: Hedera uses `transaction_id`, not hash. Format is typically `0.0.X-YYYY...`.
  rpcEndpoints: ["https://mainnet.hashio.io/api"],
  eurcAddress: null,
  usdcAddress: "0.0.456858",
  cctp: null
});
var HederaTestnet2 = defineChain2({
  type: "hedera",
  chain: Blockchain2.Hedera_Testnet,
  name: "Hedera Testnet",
  title: "Hedera Test Network",
  nativeCurrency: {
    name: "HBAR",
    symbol: "HBAR",
    decimals: 18
  },
  isTestnet: true,
  explorerUrl: "https://hashscan.io/testnet/transaction/{hash}",
  // Note: Hedera uses `transaction_id`, not hash. Format is typically `0.0.X-YYYY...`.
  rpcEndpoints: ["https://testnet.hashio.io/api"],
  eurcAddress: null,
  usdcAddress: "0.0.429274",
  cctp: null
});
var HyperEVM2 = defineChain2({
  type: "evm",
  chain: Blockchain2.HyperEVM,
  name: "HyperEVM",
  title: "HyperEVM Mainnet",
  nativeCurrency: {
    name: "Hype",
    symbol: "HYPE",
    decimals: 18
  },
  chainId: 999,
  isTestnet: false,
  explorerUrl: "https://hyperevmscan.io/tx/{hash}",
  rpcEndpoints: ["https://rpc.hyperliquid.xyz/evm"],
  eurcAddress: null,
  usdcAddress: "0xb88339CB7199b77E23DB6E890353E22632Ba630f",
  cctp: {
    domain: 19,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var HyperEVMTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.HyperEVM_Testnet,
  name: "HyperEVM Testnet",
  title: "HyperEVM Test Network",
  nativeCurrency: {
    name: "Hype",
    symbol: "HYPE",
    decimals: 18
  },
  chainId: 998,
  isTestnet: true,
  explorerUrl: "https://testnet.hyperliquid.xyz/explorer/tx/{hash}",
  rpcEndpoints: ["https://rpc.hyperliquid-testnet.xyz/evm"],
  eurcAddress: null,
  usdcAddress: "0x2B3370eE501B4a559b57D449569354196457D8Ab",
  cctp: {
    domain: 19,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Ink2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Ink,
  name: "Ink",
  title: "Ink Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 57073,
  isTestnet: false,
  explorerUrl: "https://explorer.inkonchain.com/tx/{hash}",
  rpcEndpoints: [
    "https://rpc-gel.inkonchain.com",
    "https://rpc-qnd.inkonchain.com"
  ],
  eurcAddress: null,
  usdcAddress: "0x2D270e6886d130D724215A266106e6832161EAEd",
  cctp: {
    domain: 21,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var InkTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Ink_Testnet,
  name: "Ink Sepolia",
  title: "Ink Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 763373,
  isTestnet: true,
  explorerUrl: "https://explorer-sepolia.inkonchain.com/tx/{hash}",
  rpcEndpoints: [
    "https://rpc-gel-sepolia.inkonchain.com",
    "https://rpc-qnd-sepolia.inkonchain.com"
  ],
  eurcAddress: null,
  usdcAddress: "0xFabab97dCE620294D2B0b0e46C68964e326300Ac",
  cctp: {
    domain: 21,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Linea2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Linea,
  name: "Linea",
  title: "Linea Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 59144,
  isTestnet: false,
  explorerUrl: "https://lineascan.build/tx/{hash}",
  rpcEndpoints: ["https://rpc.linea.build"],
  eurcAddress: null,
  usdcAddress: "0x176211869ca2b568f2a7d4ee941e073a821ee1ff",
  cctp: {
    domain: 11,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var LineaSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Linea_Sepolia,
  name: "Linea Sepolia",
  title: "Linea Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 59141,
  isTestnet: true,
  explorerUrl: "https://sepolia.lineascan.build/tx/{hash}",
  rpcEndpoints: ["https://rpc.sepolia.linea.build"],
  eurcAddress: null,
  usdcAddress: "0xfece4462d57bd51a6a552365a011b95f0e16d9b7",
  cctp: {
    domain: 11,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var NEAR2 = defineChain2({
  type: "near",
  chain: Blockchain2.NEAR,
  name: "NEAR Protocol",
  title: "NEAR Mainnet",
  nativeCurrency: {
    name: "NEAR",
    symbol: "NEAR",
    decimals: 24
  },
  isTestnet: false,
  explorerUrl: "https://nearblocks.io/txns/{hash}",
  rpcEndpoints: ["https://eth-rpc.mainnet.near.org"],
  eurcAddress: null,
  usdcAddress: "17208628f84f5d6ad33f0da3bbbeb27ffcb398eac501a31bd6ad2011e36133a1",
  cctp: null
});
var NEARTestnet2 = defineChain2({
  type: "near",
  chain: Blockchain2.NEAR_Testnet,
  name: "NEAR Protocol Testnet",
  title: "NEAR Test Network",
  nativeCurrency: {
    name: "NEAR",
    symbol: "NEAR",
    decimals: 24
  },
  isTestnet: true,
  explorerUrl: "https://testnet.nearblocks.io/txns/{hash}",
  rpcEndpoints: ["https://eth-rpc.testnet.near.org"],
  eurcAddress: null,
  usdcAddress: "3e2210e1184b45b64c8a434c0a7e7b23cc04ea7eb7a6c3c32520d03d4afcb8af",
  cctp: null
});
var Noble2 = defineChain2({
  type: "noble",
  chain: Blockchain2.Noble,
  name: "Noble",
  title: "Noble Mainnet",
  nativeCurrency: {
    name: "Noble USDC",
    symbol: "USDC",
    decimals: 6
  },
  isTestnet: false,
  explorerUrl: "https://www.mintscan.io/noble/tx/{hash}",
  rpcEndpoints: ["https://noble-rpc.polkachu.com"],
  eurcAddress: null,
  usdcAddress: "uusdc",
  cctp: {
    domain: 4,
    contracts: {
      v1: {
        type: "merged",
        contract: "noble12l2w4ugfz4m6dd73yysz477jszqnfughxvkss5",
        confirmations: 1
      }
    }
  }
});
var NobleTestnet2 = defineChain2({
  type: "noble",
  chain: Blockchain2.Noble_Testnet,
  name: "Noble Testnet",
  title: "Noble Test Network",
  nativeCurrency: {
    name: "Noble USDC",
    symbol: "USDC",
    decimals: 6
  },
  isTestnet: true,
  explorerUrl: "https://www.mintscan.io/noble-testnet/tx/{hash}",
  rpcEndpoints: ["https://noble-testnet-rpc.polkachu.com"],
  eurcAddress: null,
  usdcAddress: "uusdc",
  cctp: {
    domain: 4,
    contracts: {
      v1: {
        type: "merged",
        contract: "noble12l2w4ugfz4m6dd73yysz477jszqnfughxvkss5",
        confirmations: 1
      }
    }
  }
});
var Optimism2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Optimism,
  name: "Optimism",
  title: "Optimism Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 10,
  isTestnet: false,
  explorerUrl: "https://optimistic.etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://mainnet.optimism.io"],
  eurcAddress: null,
  usdcAddress: "0x0b2c639c533813f4aa9d7837caf62653d097ff85",
  cctp: {
    domain: 2,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x2B4069517957735bE00ceE0fadAE88a26365528f",
        messageTransmitter: "0x0a992d191deec32afe36203ad87d7d289a738f81",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var OptimismSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Optimism_Sepolia,
  name: "Optimism Sepolia",
  title: "Optimism Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 11155420,
  isTestnet: true,
  explorerUrl: "https://sepolia-optimistic.etherscan.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia.optimism.io"],
  eurcAddress: null,
  usdcAddress: "0x5fd84259d66Cd46123540766Be93DFE6D43130D7",
  cctp: {
    domain: 2,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Plume2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Plume,
  name: "Plume",
  title: "Plume Mainnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  chainId: 98866,
  isTestnet: false,
  explorerUrl: "https://explorer.plume.org/tx/{hash}",
  rpcEndpoints: ["https://rpc.plume.org"],
  eurcAddress: null,
  usdcAddress: "0x222365EF19F7947e5484218551B56bb3965Aa7aF",
  cctp: {
    domain: 22,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var PlumeTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Plume_Testnet,
  name: "Plume Testnet",
  title: "Plume Test Network",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  chainId: 98867,
  isTestnet: true,
  explorerUrl: "https://testnet-explorer.plume.org/tx/{hash}",
  rpcEndpoints: ["https://testnet-rpc.plume.org"],
  eurcAddress: null,
  usdcAddress: "0xcB5f30e335672893c7eb944B374c196392C19D18",
  cctp: {
    domain: 22,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var PolkadotAssetHub2 = defineChain2({
  type: "polkadot",
  chain: Blockchain2.Polkadot_Asset_Hub,
  name: "Polkadot Asset Hub",
  title: "Polkadot Asset Hub",
  nativeCurrency: {
    name: "Polkadot",
    symbol: "DOT",
    decimals: 10
  },
  isTestnet: false,
  explorerUrl: "https://polkadot.subscan.io/extrinsic/{hash}",
  rpcEndpoints: ["https://asset-hub-polkadot-rpc.n.dwellir.com"],
  eurcAddress: null,
  usdcAddress: "1337",
  cctp: null
});
var PolkadotWestmint2 = defineChain2({
  type: "polkadot",
  chain: Blockchain2.Polkadot_Westmint,
  name: "Polkadot Westmint",
  title: "Polkadot Westmint",
  nativeCurrency: {
    name: "Polkadot",
    symbol: "DOT",
    decimals: 10
  },
  isTestnet: false,
  explorerUrl: "https://assethub-polkadot.subscan.io/extrinsic/{hash}",
  rpcEndpoints: ["https://westmint-rpc.polkadot.io"],
  eurcAddress: null,
  usdcAddress: "Asset ID 31337",
  cctp: null
});
var Polygon2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Polygon,
  name: "Polygon",
  title: "Polygon Mainnet",
  nativeCurrency: {
    name: "POL",
    symbol: "POL",
    decimals: 18
  },
  chainId: 137,
  isTestnet: false,
  explorerUrl: "https://polygonscan.com/tx/{hash}",
  rpcEndpoints: ["https://polygon-rpc.com", "https://polygon.publicnode.com"],
  eurcAddress: null,
  usdcAddress: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
  cctp: {
    domain: 7,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9daF8c91AEFAE50b9c0E69629D3F6Ca40cA3B3FE",
        messageTransmitter: "0xF3be9355363857F3e001be68856A2f96b4C39Ba9",
        confirmations: 200
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 33,
        fastConfirmations: 13
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var PolygonAmoy2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Polygon_Amoy_Testnet,
  name: "Polygon Amoy",
  title: "Polygon Amoy Testnet",
  nativeCurrency: {
    name: "POL",
    symbol: "POL",
    decimals: 18
  },
  chainId: 80002,
  isTestnet: true,
  explorerUrl: "https://amoy.polygonscan.com/tx/{hash}",
  rpcEndpoints: ["https://rpc-amoy.polygon.technology"],
  eurcAddress: null,
  usdcAddress: "0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",
  cctp: {
    domain: 7,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5",
        messageTransmitter: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        confirmations: 200
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 33,
        fastConfirmations: 13
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Sei2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Sei,
  name: "Sei",
  title: "Sei Mainnet",
  nativeCurrency: {
    name: "Sei",
    symbol: "SEI",
    decimals: 18
  },
  chainId: 1329,
  isTestnet: false,
  explorerUrl: "https://seitrace.com/tx/{hash}?chain=pacific-1",
  rpcEndpoints: ["https://evm-rpc.sei-apis.com"],
  eurcAddress: null,
  usdcAddress: "0xe15fC38F6D8c56aF07bbCBe3BAf5708A2Bf42392",
  cctp: {
    domain: 16,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var SeiTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Sei_Testnet,
  name: "Sei Testnet",
  title: "Sei Test Network",
  nativeCurrency: {
    name: "Sei",
    symbol: "SEI",
    decimals: 18
  },
  chainId: 1328,
  isTestnet: true,
  explorerUrl: "https://seitrace.com/tx/{hash}?chain=atlantic-2",
  rpcEndpoints: ["https://evm-rpc-testnet.sei-apis.com"],
  eurcAddress: null,
  usdcAddress: "0x4fCF1784B31630811181f670Aea7A7bEF803eaED",
  cctp: {
    domain: 16,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Sonic2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Sonic,
  name: "Sonic",
  title: "Sonic Mainnet",
  nativeCurrency: {
    name: "Sonic",
    symbol: "S",
    decimals: 18
  },
  chainId: 146,
  isTestnet: false,
  explorerUrl: "https://sonicscan.org/tx/{hash}",
  rpcEndpoints: ["https://rpc.soniclabs.com"],
  eurcAddress: null,
  usdcAddress: "0x29219dd400f2Bf60E5a23d13Be72B486D4038894",
  cctp: {
    domain: 13,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var SonicTestnet2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Sonic_Testnet,
  name: "Sonic Testnet",
  title: "Sonic Testnet",
  nativeCurrency: {
    name: "Sonic",
    symbol: "S",
    decimals: 18
  },
  chainId: 14601,
  isTestnet: true,
  explorerUrl: "https://testnet.sonicscan.org/tx/{hash}",
  rpcEndpoints: ["https://rpc.testnet.soniclabs.com"],
  eurcAddress: null,
  usdcAddress: "0x0BA304580ee7c9a980CF72e55f5Ed2E9fd30Bc51",
  cctp: {
    domain: 13,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 1,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var Solana2 = defineChain2({
  type: "solana",
  chain: Blockchain2.Solana,
  name: "Solana",
  title: "Solana Mainnet",
  nativeCurrency: {
    name: "Solana",
    symbol: "SOL",
    decimals: 9
  },
  isTestnet: false,
  explorerUrl: "https://solscan.io/tx/{hash}",
  rpcEndpoints: ["https://api.mainnet-beta.solana.com"],
  eurcAddress: "HzwqbKZw8HxMN6bF2yFZNrht3c2iXXzpKcFu7uBEDKtr",
  usdcAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  cctp: {
    domain: 5,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3",
        messageTransmitter: "CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd",
        confirmations: 32
      },
      v2: {
        type: "split",
        tokenMessenger: "CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe",
        messageTransmitter: "CCTPV2Sm4AdWt5296sk4P66VBZ7bEhcARwFaaS9YPbeC",
        confirmations: 32,
        fastConfirmations: 3
      }
    }
  },
  kitContracts: {
    bridge: "DFaauJEjmiHkPs1JG89A4p95hDWi9m9SAEERY1LQJiC3"
  }
});
var SolanaDevnet2 = defineChain2({
  type: "solana",
  chain: Blockchain2.Solana_Devnet,
  name: "Solana Devnet",
  title: "Solana Development Network",
  nativeCurrency: {
    name: "Solana",
    symbol: "SOL",
    decimals: 9
  },
  isTestnet: true,
  explorerUrl: "https://solscan.io/tx/{hash}?cluster=devnet",
  eurcAddress: "HzwqbKZw8HxMN6bF2yFZNrht3c2iXXzpKcFu7uBEDKtr",
  usdcAddress: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
  cctp: {
    domain: 5,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3",
        messageTransmitter: "CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd",
        confirmations: 32
      },
      v2: {
        type: "split",
        tokenMessenger: "CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe",
        messageTransmitter: "CCTPV2Sm4AdWt5296sk4P66VBZ7bEhcARwFaaS9YPbeC",
        confirmations: 32,
        fastConfirmations: 3
      }
    }
  },
  kitContracts: {
    bridge: "DFaauJEjmiHkPs1JG89A4p95hDWi9m9SAEERY1LQJiC3"
  },
  rpcEndpoints: ["https://api.devnet.solana.com"]
});
var Stellar2 = defineChain2({
  type: "stellar",
  chain: Blockchain2.Stellar,
  name: "Stellar",
  title: "Stellar Mainnet",
  nativeCurrency: {
    name: "Stellar Lumens",
    symbol: "XLM",
    decimals: 7
  },
  isTestnet: false,
  explorerUrl: "https://stellar.expert/explorer/public/tx/{hash}",
  rpcEndpoints: ["https://horizon.stellar.org"],
  eurcAddress: "EURC-GDHU6WRG4IEQXM5NZ4BMPKOXHW76MZM4Y2IEMFDVXBSDP6SJY4ITNPP2",
  usdcAddress: "USDC-GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN",
  cctp: null
});
var StellarTestnet2 = defineChain2({
  type: "stellar",
  chain: Blockchain2.Stellar_Testnet,
  name: "Stellar Testnet",
  title: "Stellar Test Network",
  nativeCurrency: {
    name: "Stellar Lumens",
    symbol: "XLM",
    decimals: 7
  },
  isTestnet: true,
  explorerUrl: "https://stellar.expert/explorer/testnet/tx/{hash}",
  rpcEndpoints: ["https://horizon-testnet.stellar.org"],
  eurcAddress: "EURC-GB3Q6QDZYTHWT7E5PVS3W7FUT5GVAFC5KSZFFLPU25GO7VTC3NM2ZTVO",
  usdcAddress: "USDC-GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
  cctp: null
});
var Sui2 = defineChain2({
  type: "sui",
  chain: Blockchain2.Sui,
  name: "Sui",
  title: "Sui Mainnet",
  nativeCurrency: {
    name: "Sui",
    symbol: "SUI",
    decimals: 9
  },
  isTestnet: false,
  explorerUrl: "https://suiscan.xyz/mainnet/tx/{hash}",
  rpcEndpoints: ["https://fullnode.mainnet.sui.io"],
  eurcAddress: null,
  usdcAddress: "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
  cctp: {
    domain: 8,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x2aa6c5d56376c371f88a6cc42e852824994993cb9bab8d3e6450cbe3cb32b94e",
        messageTransmitter: "0x08d87d37ba49e785dde270a83f8e979605b03dc552b5548f26fdf2f49bf7ed1b",
        confirmations: 1
      }
    }
  }
});
var SuiTestnet2 = defineChain2({
  type: "sui",
  chain: Blockchain2.Sui_Testnet,
  name: "Sui Testnet",
  title: "Sui Test Network",
  nativeCurrency: {
    name: "Sui",
    symbol: "SUI",
    decimals: 9
  },
  isTestnet: true,
  explorerUrl: "https://suiscan.xyz/testnet/tx/{hash}",
  rpcEndpoints: ["https://fullnode.testnet.sui.io"],
  eurcAddress: null,
  usdcAddress: "0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC",
  cctp: {
    domain: 8,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x31cc14d80c175ae39777c0238f20594c6d4869cfab199f40b69f3319956b8beb",
        messageTransmitter: "0x4931e06dce648b3931f890035bd196920770e913e43e45990b383f6486fdd0a5",
        confirmations: 1
      }
    }
  }
});
var Unichain2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Unichain,
  name: "Unichain",
  title: "Unichain Mainnet",
  nativeCurrency: {
    name: "Uni",
    symbol: "UNI",
    decimals: 18
  },
  chainId: 130,
  isTestnet: false,
  explorerUrl: "https://unichain.blockscout.com/tx/{hash}",
  rpcEndpoints: ["https://rpc.unichain.org", "https://mainnet.unichain.org"],
  eurcAddress: null,
  usdcAddress: "0x078D782b760474a361dDA0AF3839290b0EF57AD6",
  cctp: {
    domain: 10,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x4e744b28E787c3aD0e810eD65A24461D4ac5a762",
        messageTransmitter: "0x353bE9E2E38AB1D19104534e4edC21c643Df86f4",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var UnichainSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.Unichain_Sepolia,
  name: "Unichain Sepolia",
  title: "Unichain Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Uni",
    symbol: "UNI",
    decimals: 18
  },
  chainId: 1301,
  isTestnet: true,
  explorerUrl: "https://unichain-sepolia.blockscout.com/tx/{hash}",
  rpcEndpoints: ["https://sepolia.unichain.org"],
  eurcAddress: null,
  usdcAddress: "0x31d0220469e10c4E71834a79b1f276d740d3768F",
  cctp: {
    domain: 10,
    contracts: {
      v1: {
        type: "split",
        tokenMessenger: "0x8ed94B8dAd2Dc5453862ea5e316A8e71AAed9782",
        messageTransmitter: "0xbc498c326533d675cf571B90A2Ced265ACb7d086",
        confirmations: 65
      },
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var WorldChain2 = defineChain2({
  type: "evm",
  chain: Blockchain2.World_Chain,
  name: "World Chain",
  title: "World Chain",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 480,
  isTestnet: false,
  explorerUrl: "https://worldscan.org/tx/{hash}",
  rpcEndpoints: ["https://worldchain-mainnet.g.alchemy.com/public"],
  eurcAddress: null,
  usdcAddress: "0x79A02482A880bCe3F13E09da970dC34dB4cD24D1",
  cctp: {
    domain: 14,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cF5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var WorldChainSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.World_Chain_Sepolia,
  name: "World Chain Sepolia",
  title: "World Chain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 4801,
  isTestnet: true,
  explorerUrl: "https://sepolia.worldscan.org/tx/{hash}",
  rpcEndpoints: [
    "https://worldchain-sepolia.drpc.org",
    "https://worldchain-sepolia.g.alchemy.com/public"
  ],
  eurcAddress: null,
  usdcAddress: "0x66145f38cBAC35Ca6F1Dfb4914dF98F1614aeA88",
  cctp: {
    domain: 14,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa",
        messageTransmitter: "0xe737e5cebeeba77efe34d4aa090756590b1ce275",
        confirmations: 65,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var XDC2 = defineChain2({
  type: "evm",
  chain: Blockchain2.XDC,
  name: "XDC",
  title: "XDC Mainnet",
  nativeCurrency: {
    name: "XDC",
    symbol: "XDC",
    decimals: 18
  },
  chainId: 50,
  isTestnet: false,
  explorerUrl: "https://xdcscan.io/tx/{hash}",
  rpcEndpoints: ["https://erpc.xinfin.network"],
  eurcAddress: null,
  usdcAddress: "0xfA2958CB79b0491CC627c1557F441eF849Ca8eb1",
  cctp: {
    domain: 18,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
        messageTransmitter: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
        confirmations: 3,
        fastConfirmations: 3
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_MAINNET2
  }
});
var XDCApothem2 = defineChain2({
  type: "evm",
  chain: Blockchain2.XDC_Apothem,
  name: "Apothem Network",
  title: "Apothem Network",
  nativeCurrency: {
    name: "TXDC",
    symbol: "TXDC",
    decimals: 18
  },
  chainId: 51,
  isTestnet: true,
  explorerUrl: "https://testnet.xdcscan.com/tx/{hash}",
  rpcEndpoints: ["https://erpc.apothem.network"],
  eurcAddress: null,
  usdcAddress: "0xb5AB69F7bBada22B28e79C8FFAECe55eF1c771D4",
  cctp: {
    domain: 18,
    contracts: {
      v2: {
        type: "split",
        tokenMessenger: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
        messageTransmitter: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
        confirmations: 3,
        fastConfirmations: 1
      }
    }
  },
  kitContracts: {
    bridge: BRIDGE_CONTRACT_EVM_TESTNET2
  }
});
var ZKSyncEra2 = defineChain2({
  type: "evm",
  chain: Blockchain2.ZKSync_Era,
  name: "ZKSync Era",
  title: "ZKSync Era Mainnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 324,
  isTestnet: false,
  explorerUrl: "https://explorer.zksync.io/tx/{hash}",
  rpcEndpoints: ["https://mainnet.era.zksync.io"],
  eurcAddress: null,
  usdcAddress: "0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4",
  cctp: null
});
var ZKSyncEraSepolia2 = defineChain2({
  type: "evm",
  chain: Blockchain2.ZKSync_Sepolia,
  name: "ZKSync Era Sepolia",
  title: "ZKSync Era Sepolia Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  chainId: 300,
  isTestnet: true,
  explorerUrl: "https://sepolia.explorer.zksync.io/tx/{hash}",
  rpcEndpoints: ["https://sepolia.era.zksync.dev"],
  eurcAddress: null,
  usdcAddress: "0xAe045DE5638162fa134807Cb558E15A3F5A7F853",
  cctp: null
});
var Blockchains = Object.freeze({
  __proto__: null,
  Algorand: Algorand2,
  AlgorandTestnet: AlgorandTestnet2,
  Aptos: Aptos2,
  AptosTestnet: AptosTestnet2,
  Arbitrum: Arbitrum2,
  ArbitrumSepolia: ArbitrumSepolia2,
  ArcTestnet: ArcTestnet2,
  Avalanche: Avalanche2,
  AvalancheFuji: AvalancheFuji2,
  Base: Base2,
  BaseSepolia: BaseSepolia2,
  Celo: Celo2,
  CeloAlfajoresTestnet: CeloAlfajoresTestnet2,
  Codex: Codex2,
  CodexTestnet: CodexTestnet2,
  Ethereum: Ethereum2,
  EthereumSepolia: EthereumSepolia2,
  Hedera: Hedera2,
  HederaTestnet: HederaTestnet2,
  HyperEVM: HyperEVM2,
  HyperEVMTestnet: HyperEVMTestnet2,
  Ink: Ink2,
  InkTestnet: InkTestnet2,
  Linea: Linea2,
  LineaSepolia: LineaSepolia2,
  NEAR: NEAR2,
  NEARTestnet: NEARTestnet2,
  Noble: Noble2,
  NobleTestnet: NobleTestnet2,
  Optimism: Optimism2,
  OptimismSepolia: OptimismSepolia2,
  Plume: Plume2,
  PlumeTestnet: PlumeTestnet2,
  PolkadotAssetHub: PolkadotAssetHub2,
  PolkadotWestmint: PolkadotWestmint2,
  Polygon: Polygon2,
  PolygonAmoy: PolygonAmoy2,
  Sei: Sei2,
  SeiTestnet: SeiTestnet2,
  Solana: Solana2,
  SolanaDevnet: SolanaDevnet2,
  Sonic: Sonic2,
  SonicTestnet: SonicTestnet2,
  Stellar: Stellar2,
  StellarTestnet: StellarTestnet2,
  Sui: Sui2,
  SuiTestnet: SuiTestnet2,
  Unichain: Unichain2,
  UnichainSepolia: UnichainSepolia2,
  WorldChain: WorldChain2,
  WorldChainSepolia: WorldChainSepolia2,
  XDC: XDC2,
  XDCApothem: XDCApothem2,
  ZKSyncEra: ZKSyncEra2,
  ZKSyncEraSepolia: ZKSyncEraSepolia2
});
var baseChainDefinitionSchema2 = external_exports.object({
  chain: external_exports.nativeEnum(Blockchain2, {
    required_error: "Chain enum is required. Please provide a valid Blockchain enum value.",
    invalid_type_error: "Chain must be a valid Blockchain enum value."
  }),
  name: external_exports.string({
    required_error: "Chain name is required. Please provide a valid chain name.",
    invalid_type_error: "Chain name must be a string."
  }),
  title: external_exports.string().optional(),
  nativeCurrency: external_exports.object({
    name: external_exports.string(),
    symbol: external_exports.string(),
    decimals: external_exports.number()
  }),
  isTestnet: external_exports.boolean({
    required_error: "isTestnet is required. Please specify whether this is a testnet.",
    invalid_type_error: "isTestnet must be a boolean."
  }),
  explorerUrl: external_exports.string({
    required_error: "Explorer URL is required. Please provide a valid explorer URL.",
    invalid_type_error: "Explorer URL must be a string."
  }),
  rpcEndpoints: external_exports.array(external_exports.string()),
  eurcAddress: external_exports.string().nullable(),
  usdcAddress: external_exports.string().nullable(),
  cctp: external_exports.any().nullable(),
  // We'll accept any CCTP config structure
  kitContracts: external_exports.object({
    bridge: external_exports.string().optional()
  }).optional()
});
var evmChainDefinitionSchema2 = baseChainDefinitionSchema2.extend({
  type: external_exports.literal("evm"),
  chainId: external_exports.number({
    required_error: "EVM chains must have a chainId. Please provide a valid EVM chain ID.",
    invalid_type_error: "EVM chain ID must be a number."
  })
}).strict();
var nonEvmChainDefinitionSchema2 = baseChainDefinitionSchema2.extend({
  type: external_exports.enum([
    "algorand",
    "avalanche",
    "solana",
    "aptos",
    "near",
    "stellar",
    "sui",
    "hedera",
    "noble",
    "polkadot"
  ])
}).strict();
var chainDefinitionSchema$12 = external_exports.discriminatedUnion("type", [
  evmChainDefinitionSchema2,
  nonEvmChainDefinitionSchema2
]);
var chainIdentifierSchema = external_exports.union([
  external_exports.string().refine((val) => val in Blockchain2, "Must be a valid Blockchain enum value as string"),
  external_exports.nativeEnum(Blockchain2),
  chainDefinitionSchema$12
]);
var getChainByEnum2 = (blockchain) => {
  const chain = Object.values(Blockchains).find((chain2) => {
    return chain2.chain === blockchain;
  });
  if (!chain) {
    throw new Error(`No chain definition found for blockchain: ${blockchain}`);
  }
  return chain;
};
function resolveChainIdentifier2(chainIdentifier) {
  if (typeof chainIdentifier === "object") {
    return chainIdentifier;
  }
  if (typeof chainIdentifier === "string") {
    return getChainByEnum2(chainIdentifier);
  }
  throw new Error(`Invalid chain identifier type: ${typeof chainIdentifier}. Expected ChainDefinition object, Blockchain enum, or string literal.`);
}
var parseUnits2 = (value, decimals) => {
  return parseUnits(value, decimals).toBigInt();
};
var ValidationError2 = class extends Error {
  constructor(message, errors) {
    super(message);
    __publicField(this, "errors");
    this.errors = errors;
    this.name = "ValidationError";
  }
};
var formatZodError2 = (error) => {
  const path = error.path.length > 0 ? `${error.path.join(".")}: ` : "";
  return `${path}${error.message}`;
};
function validate2(value, schema, context) {
  const result = schema.safeParse(value);
  if (!result.success) {
    const errors = result.error.errors.map(formatZodError2);
    const firstError = errors[0] ?? "Invalid value";
    throw new ValidationError2(`Invalid ${context}: ${firstError}`, errors);
  }
}
var VALIDATION_STATE2 = Symbol("validationState");
function validateWithStateTracking2(value, schema, context, validatorName) {
  if (value === null) {
    throw new ValidationError2(`Invalid ${context}: Value is null`, [
      `Value is null`
    ]);
  }
  if (value === void 0) {
    throw new ValidationError2(`Invalid ${context}: Value is undefined`, [
      `Value is undefined`
    ]);
  }
  if (typeof value !== "object") {
    throw new ValidationError2(`Invalid ${context}: Value must be an object`, [
      `Value must be an object, got ${typeof value}`
    ]);
  }
  const valueWithState = value;
  const state = valueWithState[VALIDATION_STATE2] ?? { validatedBy: [] };
  if (state.validatedBy.includes(validatorName)) {
    return;
  }
  validate2(value, schema, context);
  state.validatedBy.push(validatorName);
  valueWithState[VALIDATION_STATE2] = state;
}
var chainDefinitionSchema2 = external_exports.object({
  name: external_exports.string({
    required_error: "Chain name is required",
    invalid_type_error: "Chain name must be a string"
  }).min(1, "Chain name cannot be empty"),
  explorerUrl: external_exports.string({
    required_error: "Explorer URL template is required",
    invalid_type_error: "Explorer URL template must be a string"
  }).min(1, "Explorer URL template cannot be empty").refine((url) => url.includes("{hash}"), "Explorer URL template must contain a {hash} placeholder")
});
var transactionHashSchema2 = external_exports.string({
  required_error: "Transaction hash is required",
  invalid_type_error: "Transaction hash must be a string"
}).min(1, "Transaction hash cannot be empty").transform((hash) => hash.trim()).refine((hash) => hash.length > 0, "Transaction hash must not be empty or whitespace-only");
external_exports.object({
  chainDef: chainDefinitionSchema2,
  txHash: transactionHashSchema2
});
external_exports.string().url("Generated explorer URL is invalid");
var Actionable = class {
  constructor() {
    // Store event handlers by action key
    __publicField(this, "handlers", {});
    // Store wildcard handlers that receive all events
    __publicField(this, "wildcard", []);
  }
  // Implementation that handles both overloads
  on(action, handler) {
    if (action === "*") {
      this.wildcard.push(handler);
    } else {
      if (!this.handlers[action]) {
        this.handlers[action] = [];
      }
      this.handlers[action].push(handler);
    }
  }
  // Implementation that handles both overloads
  off(action, handler) {
    if (action === "*") {
      const index = this.wildcard.indexOf(handler);
      if (index !== -1) {
        this.wildcard.splice(index, 1);
      }
    } else if (this.handlers[action]) {
      const index = this.handlers[action].indexOf(handler);
      if (index !== -1) {
        this.handlers[action].splice(index, 1);
      }
    }
  }
  /**
   * Dispatch an action with its payload to all registered handlers.
   *
   * This method notifies both:
   * - Handlers registered specifically for this action
   * - Wildcard handlers registered for all actions
   *
   * @param action - The action key identifying the event type.
   * @param payload - The data associated with the action.
   *
   * @example
   * ```typescript
   * type Actions = {
   *   transferStarted: { amount: string; destination: string };
   *   transferComplete: { txHash: string };
   * };
   *
   * const events = new Actionable<Actions>();
   *
   * // Dispatch an event
   * events.dispatch('transferStarted', {
   *   amount: '100',
   *   destination: '0xABC123'
   * });
   * ```
   */
  dispatch(action, payload) {
    for (const h of this.handlers[action] ?? [])
      h(payload);
    for (const h of this.wildcard)
      h(payload);
  }
};
var name = "@circle-fin/bridge-kit";
var version = "1.1.1";
var pkg = {
  name,
  version
};
var RECOVERABILITY_VALUES2 = [
  "RETRYABLE",
  "RESUMABLE",
  "FATAL"
];
var RECOVERABILITY_ARRAY2 = [...RECOVERABILITY_VALUES2];
var errorDetailsSchema2 = external_exports.object({
  /** Numeric identifier following standardized ranges (1000+ for INPUT errors) */
  code: external_exports.number().int("Error code must be an integer").min(1e3, "Error code must be within valid range (1000+)").max(1099, "Error code must be within valid range (1099 max)"),
  /** Human-readable ID (e.g., "NETWORK_MISMATCH") */
  name: external_exports.string().min(1, "Error name must be a non-empty string").regex(/^[A-Z_][A-Z0-9_]*$/, "Error name must match pattern: ^[A-Z_][A-Z0-9_]*$"),
  /** Error handling strategy */
  recoverability: external_exports.enum(RECOVERABILITY_ARRAY2, {
    errorMap: () => ({
      message: "Recoverability must be one of: RETRYABLE, RESUMABLE, FATAL"
    })
  }),
  /** User-friendly explanation with network context */
  message: external_exports.string().min(1, "Error message must be a non-empty string").max(500, "Error message must be 500 characters or less"),
  /** Raw error details, context, or the original error that caused this one. */
  cause: external_exports.object({
    /** Free-form error payload from underlying system */
    trace: external_exports.unknown().optional()
  }).optional()
});
function validateErrorDetails2(details) {
  const result = errorDetailsSchema2.safeParse(details);
  if (!result.success) {
    const issues = result.error.issues.map((issue) => `${issue.path.join(".")}: ${issue.message}`).join(", ");
    throw new TypeError(`Invalid ErrorDetails: ${issues}`);
  }
  return result.data;
}
var KitError2 = class extends Error {
  /**
   * Create a new KitError instance.
   *
   * @param details - The error details object containing all required properties.
   * @throws \{TypeError\} When details parameter is missing or invalid.
   */
  constructor(details) {
    const validatedDetails = validateErrorDetails2(details);
    super(validatedDetails.message);
    /** Numeric identifier following standardized ranges (1000+ for INPUT errors) */
    __publicField(this, "code");
    /** Human-readable ID (e.g., "NETWORK_MISMATCH") */
    __publicField(this, "name");
    /** Error handling strategy */
    __publicField(this, "recoverability");
    /** Raw error details, context, or the original error that caused this one. */
    __publicField(this, "cause");
    Object.defineProperties(this, {
      name: {
        value: validatedDetails.name,
        writable: false,
        enumerable: true,
        configurable: false
      },
      code: {
        value: validatedDetails.code,
        writable: false,
        enumerable: true,
        configurable: false
      },
      recoverability: {
        value: validatedDetails.recoverability,
        writable: false,
        enumerable: true,
        configurable: false
      },
      ...validatedDetails.cause && {
        cause: {
          value: validatedDetails.cause,
          writable: false,
          enumerable: true,
          configurable: false
        }
      }
    });
  }
};
var INPUT_ERROR_CODE_MIN = 1e3;
var INPUT_ERROR_CODE_MAX = 1100;
var InputError2 = {
  /** Network type mismatch between chains (mainnet vs testnet) */
  NETWORK_MISMATCH: {
    code: 1001,
    name: "INPUT_NETWORK_MISMATCH"
  },
  /** Invalid amount format or value (negative, zero, or malformed) */
  INVALID_AMOUNT: {
    code: 1002,
    name: "INPUT_INVALID_AMOUNT"
  },
  /** Unsupported or invalid bridge route configuration */
  UNSUPPORTED_ROUTE: {
    code: 1003,
    name: "INPUT_UNSUPPORTED_ROUTE"
  },
  /** Invalid wallet or contract address format */
  INVALID_ADDRESS: {
    code: 1004,
    name: "INPUT_INVALID_ADDRESS"
  },
  /** Invalid or unsupported chain identifier */
  INVALID_CHAIN: {
    code: 1005,
    name: "INPUT_INVALID_CHAIN"
  },
  /** General validation failure for complex validation rules */
  VALIDATION_FAILED: {
    code: 1098,
    name: "INPUT_VALIDATION_FAILED"
  }
};
function createNetworkMismatchError2(sourceChain, destChain) {
  const sourceNetworkType = sourceChain.isTestnet ? "testnet" : "mainnet";
  const destNetworkType = destChain.isTestnet ? "testnet" : "mainnet";
  const errorDetails = {
    ...InputError2.NETWORK_MISMATCH,
    recoverability: "FATAL",
    message: `Cannot bridge between ${sourceChain.name} (${sourceNetworkType}) and ${destChain.name} (${destNetworkType}). Source and destination networks must both be testnet or both be mainnet.`,
    cause: {
      trace: { sourceChain: sourceChain.name, destChain: destChain.name }
    }
  };
  return new KitError2(errorDetails);
}
function createUnsupportedRouteError2(source, destination) {
  const errorDetails = {
    ...InputError2.UNSUPPORTED_ROUTE,
    recoverability: "FATAL",
    message: `Route from ${source} to ${destination} is not supported.`,
    cause: {
      trace: { source, destination }
    }
  };
  return new KitError2(errorDetails);
}
function createInvalidAmountError(amount, reason) {
  const errorDetails = {
    ...InputError2.INVALID_AMOUNT,
    recoverability: "FATAL",
    message: `Invalid amount '${amount}': ${reason}.`,
    cause: {
      trace: { amount, reason }
    }
  };
  return new KitError2(errorDetails);
}
function createInvalidAddressError(address, chain, expectedFormat) {
  const errorDetails = {
    ...InputError2.INVALID_ADDRESS,
    recoverability: "FATAL",
    message: `Invalid address '${address}' for ${chain}. Expected ${expectedFormat}.`,
    cause: {
      trace: { address, chain, expectedFormat }
    }
  };
  return new KitError2(errorDetails);
}
function createInvalidChainError(chain, reason) {
  const errorDetails = {
    ...InputError2.INVALID_CHAIN,
    recoverability: "FATAL",
    message: `Invalid chain '${chain}': ${reason}`,
    cause: {
      trace: { chain, reason }
    }
  };
  return new KitError2(errorDetails);
}
function isKitError(error) {
  return error instanceof KitError2;
}
function isFatalError(error) {
  return isKitError(error) && error.recoverability === "FATAL";
}
function isRetryableError2(error) {
  return isKitError(error) && error.recoverability === "RETRYABLE";
}
function isInputError(error) {
  return isKitError(error) && error.code >= INPUT_ERROR_CODE_MIN && error.code < INPUT_ERROR_CODE_MAX;
}
function getErrorMessage(error) {
  if (error instanceof Error) {
    return error.message;
  }
  if (typeof error === "string") {
    return error;
  }
  return "An unknown error occurred";
}
function getErrorCode(error) {
  return isKitError(error) ? error.code : null;
}
function extractChainInfo(chain) {
  const name2 = typeof chain === "string" ? chain : (chain == null ? void 0 : chain.name) ?? "unknown";
  const chainType = typeof chain === "object" && chain !== null ? chain.type : void 0;
  const isSolana = chainType !== void 0 ? chainType === "solana" : name2.toLowerCase().includes("solana");
  return {
    name: name2,
    displayName: name2.replace(/_/g, " "),
    expectedAddressFormat: isSolana ? "44-character base58 encoded string" : "42-character hex address starting with 0x"
  };
}
function isValidAddressForChain(address, chain) {
  const chainType = typeof chain === "object" ? chain.type : void 0;
  const name2 = typeof chain === "string" ? chain : chain.name;
  const isSolana = chainType !== void 0 ? chainType === "solana" : name2.toLowerCase().includes("solana");
  if (isSolana) {
    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
  }
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}
function isObject(val) {
  return typeof val === "object" && val !== null;
}
function isChainWithTestnet(chain) {
  return isObject(chain) && "isTestnet" in chain && typeof chain["isTestnet"] === "boolean" && "name" in chain && typeof chain["name"] === "string";
}
function getChainFromToData(toData) {
  const context = toData["context"];
  const chain = (context == null ? void 0 : context["chain"]) ?? toData["chain"];
  return chain;
}
function getChainName(params) {
  if (isObject(params)) {
    const chain = params["chain"];
    if (typeof chain === "string") {
      return chain;
    }
    if (isObject(chain) && "name" in chain) {
      return chain.name;
    }
  }
  return null;
}
function extractFromData(params) {
  return params["from"] ?? params["source"];
}
function extractToData(params) {
  return params["to"] ?? params["destination"];
}
function getAddressFromParams(params, path) {
  const parts = path.split(".");
  let current = params;
  for (const part of parts) {
    if (current !== null && current !== void 0 && typeof current === "object" && part in current) {
      current = current[part];
    } else {
      return "unknown";
    }
  }
  return typeof current === "string" ? current : "unknown";
}
function getChainFromParams(params) {
  const to = extractToData(params);
  const chain = (to == null ? void 0 : to["chain"]) ?? params["chain"];
  return chain;
}
var MAX_MESSAGE_LENGTH = 450;
function convertZodErrorToStructured(zodError, params) {
  if (params === null || params === void 0) {
    return createValidationFailedError2(zodError);
  }
  const paramsObj = params;
  const toData = extractToData(paramsObj);
  const fromData = extractFromData(paramsObj);
  for (const issue of zodError.issues) {
    const path = issue.path.join(".");
    const code = issue.code;
    const amountError = handleAmountError(path, code, issue.message, paramsObj);
    if (amountError)
      return amountError;
    const chainError = handleChainError(path, code, issue.message, fromData, toData);
    if (chainError)
      return chainError;
    const addressError = handleAddressError(path, code, issue.message, paramsObj);
    if (addressError)
      return addressError;
  }
  return createValidationFailedError2(zodError);
}
function createValidationFailedError2(zodError) {
  const issueSummary = zodError.issues.map((issue) => `${issue.path.join(".")}: ${issue.message}`).join("; ");
  const fullMessage = `Invalid parameters: ${issueSummary}`;
  const truncatedMessage = fullMessage.length > MAX_MESSAGE_LENGTH ? `${fullMessage.substring(0, MAX_MESSAGE_LENGTH)}...` : fullMessage;
  return new KitError2({
    ...InputError2.VALIDATION_FAILED,
    recoverability: "FATAL",
    message: truncatedMessage,
    cause: {
      trace: {
        originalError: zodError.message,
        zodIssues: zodError.issues
      }
    }
  });
}
function handleAmountError(path, code, message, paramsObj) {
  if (!path.includes("amount"))
    return null;
  const amount = typeof paramsObj["amount"] === "string" ? paramsObj["amount"] : "unknown";
  const negativeError = handleNegativeAmountError(code, message, amount);
  if (negativeError)
    return negativeError;
  const customError = handleCustomAmountError(code, message, amount);
  if (customError)
    return customError;
  const stringFormatError = handleInvalidStringAmountError(code, message, amount);
  if (stringFormatError)
    return stringFormatError;
  const typeError = handleInvalidTypeAmountError(code, amount);
  if (typeError)
    return typeError;
  return null;
}
function handleNegativeAmountError(code, message, amount) {
  if (code === "too_small" || message.includes("greater than")) {
    return createInvalidAmountError(amount, "Amount must be greater than 0");
  }
  return null;
}
function handleCustomAmountError(code, message, amount) {
  if (code !== "custom")
    return null;
  if (message.includes("non-negative")) {
    return createInvalidAmountError(amount, "Amount must be non-negative");
  }
  if (message.includes("decimal places")) {
    return createInvalidAmountError(amount, message);
  }
  if (message.includes("numeric string")) {
    return createInvalidAmountError(amount, "Amount must be a numeric string");
  }
  return null;
}
function handleInvalidStringAmountError(code, message, amount) {
  if (code !== "invalid_string")
    return null;
  if (amount.startsWith("-") && !isNaN(Number(amount))) {
    return createInvalidAmountError(amount, "Amount must be greater than 0");
  }
  if (isDecimalPlacesError(message)) {
    return createInvalidAmountError(amount, "Maximum supported decimal places: 6");
  }
  if (isNumericFormatError(message)) {
    return createInvalidAmountError(amount, "Amount must be a valid number format");
  }
  if (!message.includes("valid number format")) {
    return createInvalidAmountError(amount, "Amount must be a valid number string");
  }
  return null;
}
function handleInvalidTypeAmountError(code, amount) {
  if (code === "invalid_type") {
    return createInvalidAmountError(amount, "Amount must be a valid number string");
  }
  return null;
}
function isDecimalPlacesError(message) {
  return (message.includes("maximum") || message.includes("at most")) && message.includes("decimal places");
}
function isNumericFormatError(message) {
  return message.includes("numeric") && !message.includes("valid number format") && !message.includes("numeric string");
}
function handleChainError(path, _code, message, fromData, toData) {
  if (!path.includes("chain"))
    return null;
  const chain = getChainName(fromData) ?? getChainName(toData);
  return createInvalidChainError(chain ?? "unknown", message);
}
function handleAddressError(path, _code, _message, paramsObj) {
  if (!path.toLowerCase().includes("address"))
    return null;
  const address = getAddressFromParams(paramsObj, path);
  const chain = getChainFromParams(paramsObj);
  const chainInfo = extractChainInfo(chain);
  return createInvalidAddressError(address, chainInfo.displayName, chainInfo.expectedAddressFormat);
}
var assertCustomFeePolicySymbol = Symbol("assertCustomFeePolicy");
var customFeePolicySchema = external_exports.object({
  calculateFee: external_exports.function().returns(external_exports.string().or(external_exports.promise(external_exports.string()))),
  resolveFeeRecipientAddress: external_exports.function().returns(external_exports.string().or(external_exports.promise(external_exports.string())))
}).strict();
function assertCustomFeePolicy(config) {
  validateWithStateTracking2(config, customFeePolicySchema, "BridgeKit custom fee policy", assertCustomFeePolicySymbol);
}
var ASSERT_BRIDGE_PARAMS_SYMBOL = Symbol("assertBridgeParams");
function validateNetworkMatch(fromData, toData) {
  if (!isChainWithTestnet(fromData["chain"]) || !isChainWithTestnet(toData["chain"]) || fromData["chain"].isTestnet === toData["chain"].isTestnet) {
    return;
  }
  throw new KitError2({
    ...InputError2.NETWORK_MISMATCH,
    recoverability: "FATAL",
    message: `Cannot bridge between ${fromData["chain"].name} (${fromData["chain"].isTestnet ? "testnet" : "mainnet"}) and ${toData["chain"].name} (${toData["chain"].isTestnet ? "testnet" : "mainnet"}). Source and destination networks must both be testnet or both be mainnet.`,
    cause: {
      trace: {
        fromChain: fromData["chain"].name,
        toChain: toData["chain"].name,
        fromIsTestnet: fromData["chain"].isTestnet,
        toIsTestnet: toData["chain"].isTestnet
      }
    }
  });
}
function validateAddressFormat(toData) {
  if (typeof toData["address"] !== "string") {
    return;
  }
  const address = toData["address"];
  const chain = getChainFromToData(toData);
  if (chain !== null && !isValidAddressForChain(address, chain)) {
    const chainInfo = extractChainInfo(chain);
    throw createInvalidAddressError(address, chainInfo.displayName, chainInfo.expectedAddressFormat);
  }
}
function assertBridgeParams(params, schema) {
  try {
    validateWithStateTracking2(params, schema, "bridge parameters", ASSERT_BRIDGE_PARAMS_SYMBOL);
  } catch (error) {
    if (error instanceof ValidationError2) {
      const result = schema.safeParse(params);
      if (!result.success) {
        throw convertZodErrorToStructured(result.error, params);
      }
    }
    throw error;
  }
  const typedParams = params;
  const fromData = extractFromData(typedParams);
  const toData = extractToData(typedParams);
  if (fromData && toData) {
    validateNetworkMatch(fromData, toData);
  }
  if (toData) {
    validateAddressFormat(toData);
  }
}
var hexStringSchema2 = external_exports.string().min(1, "Hex string is required").refine((value) => value.trim().length > 0, "Hex string cannot be empty").refine((value) => value.startsWith("0x"), "Hex string must start with 0x prefix").refine((value) => {
  const hexPattern = /^0x[0-9a-fA-F]+$/;
  return hexPattern.test(value);
}, "Hex string contains invalid characters. Only hexadecimal characters (0-9, a-f, A-F) are allowed after 0x");
hexStringSchema2.refine((value) => value.length === 42, "EVM address must be exactly 42 characters long (0x + 40 hex characters)");
hexStringSchema2.refine((value) => value.length === 66, "Transaction hash must be exactly 66 characters long (0x + 64 hex characters)");
var base58StringSchema2 = external_exports.string().min(1, "Base58 string is required").refine((value) => value.trim().length > 0, "Base58 string cannot be empty").refine((value) => {
  const base58Pattern = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;
  return base58Pattern.test(value);
}, "Base58 string contains invalid characters. Only base58 characters (1-9, A-H, J-N, P-Z, a-k, m-z) are allowed");
base58StringSchema2.refine((value) => value.length >= 32 && value.length <= 44, "Solana address must be between 32-44 characters long (base58-encoded 32-byte address)");
base58StringSchema2.refine((value) => value.length >= 86 && value.length <= 88, "Solana transaction hash must be between 86-88 characters long (base58-encoded 64-byte signature)");
var adapterSchema = external_exports.object({
  prepare: external_exports.function(),
  waitForTransaction: external_exports.function(),
  getAddress: external_exports.function()
});
var TransferSpeed2;
(function(TransferSpeed3) {
  TransferSpeed3["FAST"] = "FAST";
  TransferSpeed3["SLOW"] = "SLOW";
})(TransferSpeed2 || (TransferSpeed2 = {}));
var createDecimalStringValidator2 = (options) => (schema) => schema.regex(/^\d+(?:[.,]\d{3})*(?:[.,]\d+)?$/, options.regexMessage).superRefine((val, ctx) => {
  const lastSeparator = val.lastIndexOf(",");
  const lastDot = val.lastIndexOf(".");
  const isCommaSeparated = lastSeparator > lastDot;
  const normalizedValue = val.replace(isCommaSeparated ? /\./g : /,/g, "").replace(isCommaSeparated ? "," : ".", ".");
  const amount = parseFloat(normalizedValue);
  if (Number.isNaN(amount)) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: options.regexMessage
    });
    return;
  }
  if (options.maxDecimals !== void 0) {
    const decimalPart = normalizedValue.split(".")[1];
    if (decimalPart && decimalPart.length > options.maxDecimals) {
      ctx.addIssue({
        code: external_exports.ZodIssueCode.custom,
        message: `Maximum supported decimal places: ${options.maxDecimals.toString()}`
      });
      return;
    }
  }
  if (options.allowZero && amount < 0) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: `${options.attributeName} must be non-negative`
    });
  } else if (!options.allowZero && amount <= 0) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: `${options.attributeName} must be greater than 0`
    });
  }
});
external_exports.object({
  name: external_exports.string().min(1, "Chain name is required"),
  type: external_exports.string().min(1, "Chain type is required")
});
var walletContextSchema2 = external_exports.object({
  adapter: external_exports.object({
    prepare: external_exports.function().returns(external_exports.any()),
    waitForTransaction: external_exports.function().returns(external_exports.any())
  }),
  address: external_exports.string().min(1),
  chain: external_exports.object({
    name: external_exports.string(),
    type: external_exports.string(),
    isTestnet: external_exports.boolean()
  })
});
var customFeeSchema2 = external_exports.object({
  /**
   * The fee to charge for the transfer as string.
   * Must be a non-negative value.
   */
  value: createDecimalStringValidator2({
    allowZero: true,
    regexMessage: "Value must be non-negative",
    attributeName: "value"
  })(external_exports.string()).optional(),
  /**
   * The fee recipient address.
   * Must be a valid address string.
   */
  recipientAddress: external_exports.string().trim().min(1, "Fee recipient must be a non-empty string").optional()
}).strict();
external_exports.object({
  amount: external_exports.string().min(1, "Required").pipe(createDecimalStringValidator2({
    allowZero: false,
    regexMessage: "Amount must be a numeric string with optional decimal places (e.g., 10.5, 10,5, 1.000,50 or 1,000.50)",
    attributeName: "amount",
    maxDecimals: 6
  })(external_exports.string())),
  source: walletContextSchema2,
  destination: walletContextSchema2,
  token: external_exports.literal("USDC"),
  config: external_exports.object({
    transferSpeed: external_exports.nativeEnum(TransferSpeed2).optional(),
    maxFee: external_exports.string().pipe(createDecimalStringValidator2({
      allowZero: true,
      regexMessage: 'maxFee must be a numeric string with optional decimal places (e.g., "1", "0.5", "1.5")',
      attributeName: "maxFee",
      maxDecimals: 6
    })(external_exports.string())).optional(),
    customFee: customFeeSchema2.optional()
  })
});
var adapterContextSchema = external_exports.object({
  adapter: adapterSchema,
  chain: chainIdentifierSchema,
  address: external_exports.string().optional()
});
var bridgeDestinationWithAddressSchema = adapterContextSchema.extend({
  recipientAddress: external_exports.string().min(1, "Recipient address is required")
}).superRefine((data, ctx) => {
  const chain = data.chain;
  if (chain === null) {
    return;
  }
  if (!isValidAddressForChain(data.recipientAddress, chain)) {
    const chainInfo = extractChainInfo(chain);
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      path: ["recipientAddress"],
      message: `Invalid address format for ${String(chainInfo.name)}. Expected ${chainInfo.expectedAddressFormat}, but received: ${data.recipientAddress}`
    });
  }
});
var bridgeDestinationSchema = external_exports.union([
  bridgeDestinationWithAddressSchema,
  adapterContextSchema.strict()
]);
var bridgeParamsWithChainIdentifierSchema = external_exports.object({
  from: adapterContextSchema.strict(),
  to: bridgeDestinationSchema,
  amount: external_exports.string().min(1, "Required").pipe(createDecimalStringValidator2({
    allowZero: false,
    regexMessage: "Amount must be a numeric string with optional decimal places (e.g., 10.5, 10,5, 1.000,50 or 1,000.50)",
    attributeName: "amount",
    maxDecimals: 6
  })(external_exports.string())),
  token: external_exports.literal("USDC").optional(),
  config: external_exports.object({
    transferSpeed: external_exports.nativeEnum(TransferSpeed2).optional(),
    maxFee: external_exports.string().min(1, "Required").pipe(createDecimalStringValidator2({
      allowZero: true,
      regexMessage: "Max fee must be a numeric string with optional decimal places (e.g., 1, 0.5, 1.5)",
      attributeName: "maxFee",
      maxDecimals: 6
    })(external_exports.string())).optional(),
    customFee: customFeeSchema2.optional()
  }).optional()
});
function resolveChainDefinition(ctx) {
  return resolveChainIdentifier2(ctx.chain);
}
async function resolveAddress(ctx) {
  var _a;
  if (((_a = ctx.adapter.capabilities) == null ? void 0 : _a.addressContext) === "developer-controlled") {
    if ("address" in ctx && ctx.address) {
      return ctx.address;
    }
    throw new Error('Address is required in context for developer-controlled adapters. Please provide: { adapter, chain, address: "0x..." }');
  } else {
    if ("address" in ctx && ctx.address) {
      throw new Error("Address should not be provided for user-controlled adapters. The address is automatically resolved from the connected wallet.");
    }
    const chain = resolveChainDefinition(ctx);
    return await ctx.adapter.getAddress(chain);
  }
}
function resolveAmount(params) {
  if (params.token === "USDC") {
    return parseUnits2(params.amount, 6).toString();
  }
  return params.amount;
}
function resolveConfig(params) {
  var _a, _b, _c;
  const maxFee = ((_a = params.config) == null ? void 0 : _a.maxFee) ? parseUnits2(params.config.maxFee, 6).toString() : void 0;
  const rawCustomFee = (_b = params.config) == null ? void 0 : _b.customFee;
  const customFee = rawCustomFee ? {
    ...rawCustomFee,
    value: rawCustomFee.value ? parseUnits2(rawCustomFee.value, 6).toString() : void 0
  } : void 0;
  return {
    ...params.config,
    transferSpeed: ((_c = params.config) == null ? void 0 : _c.transferSpeed) ?? TransferSpeed2.FAST,
    ...maxFee !== void 0 && { maxFee },
    ...customFee !== void 0 && { customFee }
  };
}
async function resolveBridgeParams(params) {
  const fromChain = resolveChainDefinition(params.from);
  const toChain = resolveChainDefinition(params.to);
  const [fromAddress, toAddress] = await Promise.all([
    resolveAddress(params.from),
    resolveAddress(params.to)
  ]);
  const token = params.token ?? "USDC";
  const fromAdapter = params.from.adapter;
  const toAdapter = params.to.adapter;
  const recipientAddress = "recipientAddress" in params.to ? params.to.recipientAddress : void 0;
  return {
    amount: resolveAmount({
      ...params,
      token
    }),
    token,
    config: resolveConfig({
      ...params
    }),
    source: {
      adapter: fromAdapter,
      chain: fromChain,
      address: fromAddress
    },
    destination: {
      adapter: toAdapter,
      chain: toChain,
      address: toAddress,
      ...recipientAddress !== void 0 && { recipientAddress }
    }
  };
}
var getDefaultProviders = () => [new CCTPV2BridgingProvider()];
var BridgeKit = class {
  /**
   * Create a new BridgeKit instance.
   *
   * @param config - The configuration containing the CCTPv2 provider
   *
   * @example
   * ```typescript
   * import { BridgeKit } from '@circle-fin/bridge-kit'
   *
   * const kit = new BridgeKit()
   * ```
   */
  constructor(config = {}) {
    /**
     * The providers used for executing transfers.
     */
    __publicField(this, "providers");
    /**
     * The action dispatcher for the kit.
     */
    __publicField(this, "actionDispatcher");
    /**
     * A custom fee policy for the kit.
     */
    __publicField(this, "customFeePolicy");
    const defaultProviders = getDefaultProviders();
    this.providers = [...defaultProviders, ...config.providers ?? []];
    this.actionDispatcher = new Actionable();
    for (const provider of this.providers) {
      provider.registerDispatcher(this.actionDispatcher);
    }
  }
  // implementation just forwards to the bus
  on(actionOrWildCard, handler) {
    this.actionDispatcher.on(actionOrWildCard, handler);
  }
  // implementation just forwards to the bus
  off(actionOrWildCard, handler) {
    this.actionDispatcher.off(actionOrWildCard, handler);
  }
  /**
   * Execute a cross-chain USDC transfer using CCTPv2.
   *
   * Handle the complete CCTPv2 transfer flow, including parameter validation,
   * chain resolution, and transfer execution. Provide comprehensive validation of
   * all parameters before initiating the transfer.
   *
   * Perform validation of:
   * - Source and destination wallet contexts
   * - Chain identifiers (string, enum, or chain definition)
   * - Amount format and token type
   * - CCTPv2 support for the chain pair
   * - Transfer configuration options
   *
   * @param params - The transfer parameters containing source, destination, amount, and token
   * @returns Promise resolving to the transfer result with transaction details and steps
   * @throws {ValidationError} When any parameter validation fails.
   * @throws {Error} When CCTPv2 does not support the specified route.
   *
   * @example
   * ```typescript
   * import { BridgeKit } from '@circle-fin/bridge-kit'
   * import { createAdapterFromPrivateKey } from '@circle-fin/adapter-viem-v2'
   *
   * const kit = new BridgeKit()
   *
   * // Create a single adapter that can work across chains
   * const adapter = createAdapterFromPrivateKey({
   *   privateKey: process.env.PRIVATE_KEY,
   * })
   *
   * const result = await kit.bridge({
   *   from: {
   *     adapter,
   *     chain: 'Ethereum'
   *   },
   *   to: {
   *     adapter,
   *     chain: 'Base'
   *   },
   *   amount: '100.50'
   * })
   *
   * // Handle result
   * if (result.state === 'success') {
   *   console.log('Bridge completed!')
   *   result.steps.forEach(step => {
   *     console.log(`${step.name}: ${step.explorerUrl}`)
   *   })
   * } else {
   *   console.error('Bridge failed:', result.steps)
   * }
   * ```
   */
  async bridge(params) {
    assertBridgeParams(params, bridgeParamsWithChainIdentifierSchema);
    const resolvedParams = await resolveBridgeParams(params);
    this.validateNetworkCompatibility(resolvedParams);
    const finalResolvedParams = await this.mergeCustomFeeConfig(resolvedParams);
    const provider = this.findProviderForRoute(finalResolvedParams);
    return provider.bridge(finalResolvedParams);
  }
  /**
   * Retry a failed or incomplete cross-chain USDC bridge operation.
   *
   * Provide a high-level interface for resuming bridge operations that have failed
   * or become stuck during execution. Automatically identify the provider that was
   * used for the original transfer and delegate the retry logic to that provider's
   * implementation.
   *
   * Use this functionality to handle:
   * - Network timeouts or temporary connectivity issues
   * - Gas estimation failures that can be resolved with updated parameters
   * - Pending transactions that need to be resubmitted
   * - Failed steps in multi-step bridge flows
   *
   * @param result - The bridge result from a previous failed or incomplete operation.
   *                 Must contain the provider name and step execution history.
   * @param context - The retry context containing fresh adapter instances for both
   *                  source and destination chains. These adapters should be properly
   *                  configured with current network connections and signing capabilities.
   * @returns A promise that resolves to the updated bridge result after retry execution.
   *          The result will contain the complete step history including both original
   *          and retry attempts.
   *
   * @throws {Error} When the original provider specified in the result is not found
   *         in the current kit configuration.
   * @throws {Error} When the underlying provider's retry operation fails due to
   *         non-recoverable errors or invalid state.
   *
   * @example
   * ```typescript
   * import { BridgeKit } from '@circle-fin/bridge-kit'
   * import { createAdapterFromPrivateKey } from '@circle-fin/adapter-viem-v2'
   *
   * const kit = new BridgeKit()
   *
   * // Assume we have a failed bridge result from a previous operation
   * const failedResult: BridgeResult = {
   *   state: 'error',
   *   provider: 'CCTPV2BridgingProvider',
   *   steps: [
   *     { name: 'approve', state: 'success', txHash: '0x123...' },
   *     { name: 'burn', state: 'error', errorMessage: 'Gas limit exceeded' }
   *   ],
   *   // ... other properties
   * }
   *
   *
   * try {
   *   const retryResult = await kit.retry(failedResult, {
   *     from: sourceAdapter,
   *     to: destAdapter
   *   })
   *
   *   console.log('Retry completed successfully:', retryResult.state)
   *   console.log('Total steps executed:', retryResult.steps.length)
   * } catch (error) {
   *   console.error('Retry failed:', error.message)
   *   // Handle retry failure (may require manual intervention)
   * }
   * ```
   */
  async retry(result, context) {
    const provider = this.providers.find((p) => p.name === result.provider);
    if (!provider) {
      throw new Error(`Provider ${result.provider} not found`);
    }
    return provider.retry(result, context);
  }
  /**
   * Estimate the cost and fees for a cross-chain USDC bridge operation.
   *
   * This method calculates the expected gas fees and protocol costs for bridging
   * without actually executing the transaction. It performs the same validation
   * as the bridge method but stops before execution.
   * @param params - The bridge parameters for cost estimation
   * @returns Promise resolving to detailed cost breakdown including gas estimates
   * @throws {ValidationError} When the parameters are invalid.
   * @throws {UnsupportedRouteError} When the route is not supported.
   *
   * @example
   * ```typescript
   * const estimate = await kit.estimate({
   *   from: { adapter: adapter, chain: 'Ethereum' },
   *   to: { adapter: adapter, chain: 'Base' },
   *   amount: '10.50',
   *   token: 'USDC'
   * })
   * console.log('Estimated cost:', estimate.totalCost)
   * ```
   */
  async estimate(params) {
    assertBridgeParams(params, bridgeParamsWithChainIdentifierSchema);
    const resolvedParams = await resolveBridgeParams(params);
    this.validateNetworkCompatibility(resolvedParams);
    const finalResolvedParams = await this.mergeCustomFeeConfig(resolvedParams);
    const provider = this.findProviderForRoute(finalResolvedParams);
    return provider.estimate(finalResolvedParams);
  }
  /**
   * Get all chains supported by any provider in the kit.
   *
   * Aggregate and deduplicate the supported chains from all registered providers.
   * This provides a comprehensive list of chains that can be used as either source
   * or destination for transfers through this kit instance.
   *
   * The method automatically deduplicates chains based on their chain identifier,
   * ensuring each chain appears only once in the result regardless of how many
   * providers support it.
   *
   * @returns Array of unique chain definitions supported by the registered providers
   *
   * @example
   * ```typescript
   * import { BridgeKit } from '@circle-fin/bridge-kit'
   *
   * const kit = new BridgeKit()
   * const chains = kit.getSupportedChains()
   *
   * console.log('Supported chains:')
   * chains.forEach(chain => {
   *   console.log(`- ${chain.name} (${chain.type})`)
   * })
   * ```
   */
  getSupportedChains() {
    const supportedChains = this.providers.flatMap((p) => p.supportedChains);
    return Object.values(Object.fromEntries(supportedChains.map((chain) => [chain.chain, chain])));
  }
  /**
   * Validate that source and destination chains are on the same network type.
   *
   * This method ensures that both chains are either testnet or mainnet, preventing
   * cross-network transfers which are not supported by the bridging protocols.
   *
   * @param resolvedParams - The resolved bridge parameters containing source and destination chains
   * @throws {NetworkMismatchError} If source and destination chains are on different network types
   */
  validateNetworkCompatibility(resolvedParams) {
    if (resolvedParams.source.chain.isTestnet !== resolvedParams.destination.chain.isTestnet) {
      throw createNetworkMismatchError2(resolvedParams.source.chain, resolvedParams.destination.chain);
    }
  }
  /**
   * Find a provider that supports the given transfer route.
   *
   * This method centralizes the provider selection logic to ensure consistency
   * between transfer and estimate operations. It resolves the source and destination
   * chains from the provided adapters and finds the first provider that supports
   * the route for the specified token.
   *
   * @param params - The transfer parameters containing source, destination, and token
   * @returns Promise resolving to the provider that supports this route
   * @throws Will throw an error if no provider supports the route
   */
  findProviderForRoute(params) {
    const provider = this.providers.find((p) => p.supportsRoute(params.source.chain, params.destination.chain, params.token));
    if (!provider) {
      throw createUnsupportedRouteError2(params.source.chain.name, params.destination.chain.name);
    }
    return provider;
  }
  /**
   * Merge custom fee configuration into provider parameters.
   *
   * Prioritizes any custom fee configuration already present on the
   * provider-resolved params and uses the kit-level custom fee configuration
   * as a fallback only when a value is missing. If neither the provider params
   * nor the kit configuration can supply a value, no custom fee configuration
   * is added to the provider params.
   *
   * @param originalParams - The original bridge parameters received by the kit.
   * @param providerParams - The provider-resolved bridge parameters that may be enriched.
   * @returns The same `providerParams` reference with custom fee configuration merged when applicable.
   *
   * @remarks
   * - Existing values on `providerParams.config.customFee` are preserved.
   * - Kit-level functions are invoked lazily and only for missing values.
   * - If both sources provide no values, `customFee` is omitted entirely.
   */
  async mergeCustomFeeConfig(providerParams) {
    var _a, _b, _c, _d, _e, _f;
    const existingFee = (_b = (_a = providerParams.config) == null ? void 0 : _a.customFee) == null ? void 0 : _b.value;
    const existingFeeRecipient = (_d = (_c = providerParams.config) == null ? void 0 : _c.customFee) == null ? void 0 : _d.recipientAddress;
    const fee = existingFee ?? await ((_e = this.customFeePolicy) == null ? void 0 : _e.calculateFee(providerParams));
    const feeRecipient = existingFeeRecipient ?? await ((_f = this.customFeePolicy) == null ? void 0 : _f.resolveFeeRecipientAddress(providerParams.source.chain, providerParams));
    if (fee !== void 0 || feeRecipient !== void 0) {
      providerParams.config = {
        ...providerParams.config,
        customFee: {
          value: fee,
          recipientAddress: feeRecipient
        }
      };
    }
    return providerParams;
  }
  /**
   * Sets the custom fee policy for the kit.
   *
   * Ensures the fee is represented in the smallest unit of the token.
   * - If the token is USDC, the fee is converted to base units (6 decimals).
   * - If the token is not USDC, the fee is returned as is.
   *
   * This allows developers to specify the kit-level fee in base units (e.g., USDC: 1, ETH: 0.000001),
   * and the kit will handle conversion to the smallest unit as needed.
   *
   * @param customFeePolicy - The custom fee policy to set.
   * @throws {ValidationError} If the custom fee policy is invalid or missing required functions
   *
   * @example
   * ```typescript
   * import { BridgeKit } from '@circle-fin/bridge-kit'
   * import { Blockchain } from '@core/chains'
   *
   * const kit = new BridgeKit()
   *
   * kit.setCustomFeePolicy({
   *   calculateFee: (params) => {
   *     // Return decimal string - kit converts to smallest units automatically
   *     // '0.1' becomes '100000' (0.1 USDC with 6 decimals)
   *     return params.source.chain.chain === Blockchain.Ethereum_Sepolia
   *       ? '0.1'  // 0.1 USDC
   *       : '0.2'; // 0.2 USDC
   *   },
   *   resolveFeeRecipientAddress: (feePayoutChain, params) => {
   *     // Return valid address for the source chain
   *     return params.source.chain.chain === Blockchain.Ethereum_Sepolia
   *       ? '0x23f9a5BEA7B92a0638520607407BC7f0310aEeD4'
   *       : '0x1E1A18B7bD95bcFcFb4d6E245D289C1e95547b35';
   *   },
   * });
   * ```
   */
  setCustomFeePolicy(customFeePolicy) {
    assertCustomFeePolicy(customFeePolicy);
    const { calculateFee, resolveFeeRecipientAddress } = customFeePolicy;
    const formattedCalculateFee = async (params) => {
      const fee = await calculateFee(params);
      const token = params.token ?? "USDC";
      return token === "USDC" ? parseUnits2(fee, 6).toString() : fee;
    };
    this.customFeePolicy = {
      calculateFee: formattedCalculateFee,
      resolveFeeRecipientAddress
    };
  }
  /**
   * Remove the custom fee policy for the kit.
   *
   * @example
   * ```typescript
   * kit.removeCustomFeePolicy()
   * ```
   */
  removeCustomFeePolicy() {
    this.customFeePolicy = void 0;
  }
};
registerKit(`${pkg.name}/${pkg.version}`);
export {
  Blockchain2 as Blockchain,
  BridgeKit,
  KitError2 as KitError,
  TransferSpeed2 as TransferSpeed,
  bridgeParamsWithChainIdentifierSchema,
  getErrorCode,
  getErrorMessage,
  isFatalError,
  isInputError,
  isKitError,
  isRetryableError2 as isRetryableError,
  setExternalPrefix
};
//# sourceMappingURL=@circle-fin_bridge-kit.js.map
